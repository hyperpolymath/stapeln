// Generated by ReScript, PLEASE EDIT WITH CARE


function cspResultFromInt(code) {
  switch (code) {
    case 0 :
      return "CSPValid";
    case 1 :
      return "InvalidChars";
    case 2 :
      return "ScriptDetected";
    default:
      return "TooLong";
  }
}

function severityToInt(sev) {
  switch (sev) {
    case "Info" :
      return 0;
    case "Warning" :
      return 1;
    case "Error" :
      return 2;
    case "Critical" :
      return 3;
  }
}

function sandboxModeToInt(mode) {
  switch (mode) {
    case "NoSandbox" :
      return 0;
    case "IframeSandbox" :
      return 1;
    case "ShadowDOMSandbox" :
      return 2;
  }
}

let FFI = {
  cspResultFromInt: cspResultFromInt,
  severityToInt: severityToInt,
  sandboxModeToInt: sandboxModeToInt
};

function validateCSP(elementId) {
  return cspResultFromInt(validate_csp(elementId));
}

function isCSPValid(elementId) {
  let match = validateCSP(elementId);
  return match === "CSPValid";
}

function cspErrorMessage(result) {
  switch (result) {
    case "CSPValid" :
      return "Element ID is CSP compliant";
    case "InvalidChars" :
      return "Element ID contains invalid characters (only alphanumeric, dash, underscore allowed)";
    case "ScriptDetected" :
      return "Element ID contains script injection attempt (script tags, javascript:, event handlers detected)";
    case "TooLong" :
      return "Element ID is empty or exceeds 255 character limit";
  }
}

function logAudit(operation, elementId, severity, message) {
  let code = audit_log_entry(operation, elementId, severityToInt(severity), message);
  if (code === 0) {
    return {
      TAG: "Ok",
      _0: undefined
    };
  } else {
    return {
      TAG: "Error",
      _0: "Failed to log audit entry (log may be full)"
    };
  }
}

function logMountAttempt(elementId, success) {
  let severity = success ? "Info" : "Error";
  let message = success ? `Successfully mounted to ` + elementId : `Failed to mount to ` + elementId;
  logAudit("mount", elementId, severity, message);
}

function logSecurityViolation(elementId, reason) {
  logAudit("security_violation", elementId, "Critical", `Security violation: ` + reason);
}

function getAuditLogCount() {
  return get_audit_log_count();
}

function clearAuditLog() {
  clear_audit_log();
}

function createSandboxedMount(elementId, mode) {
  let code = create_sandboxed_mount(elementId, sandboxModeToInt(mode));
  switch (code) {
    case -2 :
      return {
        TAG: "Error",
        _0: "Invalid sandbox mode"
      };
    case -1 :
      return {
        TAG: "Error",
        _0: "Invalid element ID for sandboxed mount"
      };
    case 0 :
      return {
        TAG: "Ok",
        _0: undefined
      };
    default:
      return {
        TAG: "Error",
        _0: "Failed to create sandboxed mount"
      };
  }
}

function validateSandboxConfig(allowScripts, allowSameOrigin, allowForms) {
  let code = validate_sandbox_config(allowScripts ? 1 : 0, allowSameOrigin ? 1 : 0, allowForms ? 1 : 0);
  return code === 0;
}

let defaultSecurityPolicy = {
  requireCSP: true,
  enableAuditLog: true,
  sandboxMode: "NoSandbox",
  maxElementIdLength: 255
};

function secureMount(elementId, policy) {
  let cspResult;
  if (policy.requireCSP) {
    let match = validateCSP(elementId);
    switch (match) {
      case "CSPValid" :
        cspResult = {
          TAG: "Ok",
          _0: undefined
        };
        break;
      case "InvalidChars" :
        if (policy.enableAuditLog) {
          logSecurityViolation(elementId, "Invalid characters in element ID");
        }
        cspResult = {
          TAG: "Error",
          _0: "CSP validation failed: Element ID contains invalid characters (only alphanumeric, dash, underscore allowed)"
        };
        break;
      case "ScriptDetected" :
        if (policy.enableAuditLog) {
          logSecurityViolation(elementId, "Script injection detected in element ID");
        }
        cspResult = {
          TAG: "Error",
          _0: "CSP validation failed: Element ID contains script injection attempt (script tags, javascript:, event handlers detected)"
        };
        break;
      case "TooLong" :
        cspResult = {
          TAG: "Error",
          _0: "CSP validation failed: Element ID is empty or exceeds 255 character limit"
        };
        break;
    }
  } else {
    cspResult = {
      TAG: "Ok",
      _0: undefined
    };
  }
  if (cspResult.TAG === "Ok") {
    if (elementId.length > policy.maxElementIdLength) {
      return {
        TAG: "Error",
        _0: `Element ID exceeds maximum length of ` + String(policy.maxElementIdLength)
      };
    } else {
      if (policy.enableAuditLog) {
        logMountAttempt(elementId, true);
      }
      return {
        TAG: "Ok",
        _0: undefined
      };
    }
  } else {
    return {
      TAG: "Error",
      _0: cspResult._0
    };
  }
}

function mountSecure(elementId) {
  return secureMount(elementId, defaultSecurityPolicy);
}

let mountWithPolicy = secureMount;

function mountSandboxed(elementId, mode) {
  let e = secureMount(elementId, defaultSecurityPolicy);
  if (e.TAG === "Ok") {
    return createSandboxedMount(elementId, mode);
  } else {
    return {
      TAG: "Error",
      _0: e._0
    };
  }
}

export {
  FFI,
  validateCSP,
  isCSPValid,
  cspErrorMessage,
  logAudit,
  logMountAttempt,
  logSecurityViolation,
  getAuditLogCount,
  clearAuditLog,
  createSandboxedMount,
  validateSandboxConfig,
  defaultSecurityPolicy,
  secureMount,
  mountSecure,
  mountWithPolicy,
  mountSandboxed,
}
/* No side effect */
