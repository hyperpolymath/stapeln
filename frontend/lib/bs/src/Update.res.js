// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Model from "./Model.res.js";
import * as Export from "./Export.res.js";
import * as Import from "./Import.res.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";

function update(model, msg) {
  if (typeof msg !== "object") {
    switch (msg) {
      case "DragEnd" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: "NotDragging",
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "ZoomIn" :
        let newZoom = Math.min(model.zoomLevel * 1.2, 3.0);
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: newZoom,
          validationResult: model.validationResult
        };
      case "ZoomOut" :
        let newZoom$1 = Math.max(model.zoomLevel / 1.2, 0.5);
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: newZoom$1,
          validationResult: model.validationResult
        };
      case "ResetZoom" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: {
            x: 0.0,
            y: 0.0
          },
          zoomLevel: 1.0,
          validationResult: model.validationResult
        };
      case "ValidateStack" :
        let result_valid = model.components.length !== 0;
        let result_errors = [];
        let result_warnings = model.components.length === 0 ? ["Stack is empty"] : [];
        let result = {
          valid: result_valid,
          errors: result_errors,
          warnings: result_warnings
        };
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: result
        };
      case "ExportToSelurCompose" :
        Export.exportToSelurCompose(model);
        return model;
      case "ExportToDockerCompose" :
        Export.exportToDockerCompose(model);
        return model;
      case "ExportToPodmanCompose" :
        Export.exportToPodmanCompose(model);
        return model;
      case "TriggerImportDesign" :
        Import.triggerImport(importedModel => {
          console.log("Design imported successfully:", importedModel);
        }, error => {
          console.error("Import failed:", error);
        });
        return model;
      case "SaveStack" :
        console.log("Saving stack...");
        return model;
    }
  } else {
    switch (msg.TAG) {
      case "AddComponent" :
        let newComponent_id = Model.generateId();
        let newComponent_componentType = msg._0;
        let newComponent_position = msg._1;
        let newComponent_config = {};
        let newComponent = {
          id: newComponent_id,
          componentType: newComponent_componentType,
          position: newComponent_position,
          config: newComponent_config
        };
        return {
          components: Belt_Array.concat(model.components, [newComponent]),
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "RemoveComponent" :
        let id = msg._0;
        let newComponents = Belt_Array.keep(model.components, c => c.id !== id);
        let newConnections = Belt_Array.keep(model.connections, conn => {
          if (conn.from !== id) {
            return conn.to !== id;
          } else {
            return false;
          }
        });
        return {
          components: newComponents,
          connections: newConnections,
          selectedComponent: model.selectedComponent === id ? undefined : model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "UpdateComponentPosition" :
        let position = msg._1;
        let id$1 = msg._0;
        let newComponents$1 = Belt_Array.map(model.components, comp => {
          if (comp.id === id$1) {
            return {
              id: comp.id,
              componentType: comp.componentType,
              position: position,
              config: comp.config
            };
          } else {
            return comp;
          }
        });
        return {
          components: newComponents$1,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "UpdateComponentConfig" :
        let config = msg._1;
        let id$2 = msg._0;
        let newComponents$2 = Belt_Array.map(model.components, comp => {
          if (comp.id === id$2) {
            return {
              id: comp.id,
              componentType: comp.componentType,
              position: comp.position,
              config: config
            };
          } else {
            return comp;
          }
        });
        return {
          components: newComponents$2,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "SelectComponent" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: msg._0,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "AddConnection" :
        let toId = msg._1;
        let fromId = msg._0;
        let fromExists = Belt_Array.some(model.components, c => c.id === fromId);
        let toExists = Belt_Array.some(model.components, c => c.id === toId);
        if (!(fromExists && toExists)) {
          return model;
        }
        let newConnection_id = Model.generateId();
        let newConnection = {
          id: newConnection_id,
          from: fromId,
          to: toId
        };
        return {
          components: model.components,
          connections: Belt_Array.concat(model.connections, [newConnection]),
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "RemoveConnection" :
        let id$3 = msg._0;
        let newConnections$1 = Belt_Array.keep(model.connections, conn => conn.id !== id$3);
        return {
          components: model.components,
          connections: newConnections$1,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "StartDragComponent" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: {
            TAG: "DraggingComponent",
            _0: msg._0
          },
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "StartDragCanvas" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: {
            TAG: "DraggingCanvas",
            _0: msg._0
          },
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "DragMove" :
        let mousePos = msg._0;
        let component = model.dragState;
        if (typeof component !== "object") {
          return model;
        }
        if (component.TAG === "DraggingComponent") {
          let component$1 = component._0;
          let newComponents$3 = Belt_Array.map(model.components, comp => {
            if (comp.id === component$1.id) {
              return {
                id: comp.id,
                componentType: comp.componentType,
                position: mousePos,
                config: comp.config
              };
            } else {
              return comp;
            }
          });
          return {
            components: newComponents$3,
            connections: model.connections,
            selectedComponent: model.selectedComponent,
            dragState: {
              TAG: "DraggingComponent",
              _0: {
                id: component$1.id,
                componentType: component$1.componentType,
                position: mousePos,
                config: component$1.config
              }
            },
            canvasOffset: model.canvasOffset,
            zoomLevel: model.zoomLevel,
            validationResult: model.validationResult
          };
        }
        let startPos = component._0;
        let deltaX = mousePos.x - startPos.x;
        let deltaY = mousePos.y - startPos.y;
        let newOffset_x = model.canvasOffset.x + deltaX;
        let newOffset_y = model.canvasOffset.y + deltaY;
        let newOffset = {
          x: newOffset_x,
          y: newOffset_y
        };
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: {
            TAG: "DraggingCanvas",
            _0: mousePos
          },
          canvasOffset: newOffset,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "PanCanvas" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: msg._0,
          zoomLevel: model.zoomLevel,
          validationResult: model.validationResult
        };
      case "ValidationResult" :
        return {
          components: model.components,
          connections: model.connections,
          selectedComponent: model.selectedComponent,
          dragState: model.dragState,
          canvasOffset: model.canvasOffset,
          zoomLevel: model.zoomLevel,
          validationResult: msg._0
        };
      case "ExportDesignToJson" :
        Export.exportDesignToJson(model, msg._0);
        return model;
      case "ImportDesignSuccess" :
        console.log("Design imported successfully");
        return msg._0;
      case "ImportDesignError" :
        console.error("Import failed:", msg._0);
        return model;
      case "LoadStack" :
        console.log("Loading stack:", msg._0);
        return model;
      case "StackSaved" :
        let result$1 = msg._0;
        if (result$1.TAG === "Ok") {
          console.log("Stack saved with ID:", result$1._0);
          return model;
        }
        console.error("Failed to save stack:", result$1._0);
        return model;
      case "StackLoaded" :
        let result$2 = msg._0;
        if (result$2.TAG === "Ok") {
          console.log("Stack loaded successfully");
          return result$2._0;
        }
        console.error("Failed to load stack:", result$2._0);
        return model;
    }
  }
}

export {
  update,
}
/* Export Not a pure module */
