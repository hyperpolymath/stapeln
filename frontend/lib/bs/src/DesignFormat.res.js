// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Model from "./Model.res.js";
import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function componentToJson(comp) {
  let configJson = Js_dict.fromArray(Belt_Array.map(Js_dict.entries(comp.config), param => [
    param[0],
    param[1]
  ]));
  return Js_dict.fromArray([
    [
      "id",
      comp.id
    ],
    [
      "type",
      Model.componentTypeToString(comp.componentType)
    ],
    [
      "position",
      Js_dict.fromArray([
        [
          "x",
          comp.position.x
        ],
        [
          "y",
          comp.position.y
        ]
      ])
    ],
    [
      "config",
      configJson
    ]
  ]);
}

function componentFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let id = Belt_Option.flatMap(Js_dict.get(obj$1, "id"), Js_json.decodeString);
  let typeStr = Belt_Option.flatMap(Js_dict.get(obj$1, "type"), Js_json.decodeString);
  let position = Belt_Option.flatMap(Js_dict.get(obj$1, "position"), posJson => {
    let posObj = Js_json.classify(posJson);
    if (typeof posObj !== "object") {
      return;
    }
    if (posObj.TAG !== "JSONObject") {
      return;
    }
    let posObj$1 = posObj._0;
    let x = Belt_Option.flatMap(Js_dict.get(posObj$1, "x"), Js_json.decodeNumber);
    let y = Belt_Option.flatMap(Js_dict.get(posObj$1, "y"), Js_json.decodeNumber);
    if (x !== undefined && y !== undefined) {
      return {
        x: x,
        y: y
      };
    }
  });
  let config = Belt_Option.flatMap(Js_dict.get(obj$1, "config"), cfg => {
    let dict = Js_json.classify(cfg);
    if (typeof dict !== "object") {
      return;
    }
    if (dict.TAG !== "JSONObject") {
      return;
    }
    let stringDict = {};
    Belt_Array.forEach(Js_dict.entries(dict._0), param => {
      let str = Js_json.decodeString(param[1]);
      if (str !== undefined) {
        stringDict[param[0]] = str;
        return;
      }
    });
    return stringDict;
  });
  let componentType;
  if (typeStr !== undefined) {
    switch (typeStr) {
      case "Cerro Torre" :
        componentType = "CerroTorre";
        break;
      case "Docker" :
        componentType = "Docker";
        break;
      case "Lago Grey" :
        componentType = "LagoGrey";
        break;
      case "Network" :
        componentType = "Network";
        break;
      case "Podman" :
        componentType = "Podman";
        break;
      case "Svalinn" :
        componentType = "Svalinn";
        break;
      case "Volume" :
        componentType = "Volume";
        break;
      case "Vörðr" :
        componentType = "Vordr";
        break;
      case "nerdctl" :
        componentType = "Nerdctl";
        break;
      case "selur" :
        componentType = "Selur";
        break;
      default:
        componentType = undefined;
    }
  } else {
    componentType = undefined;
  }
  if (id !== undefined && componentType !== undefined && position !== undefined && config !== undefined) {
    return {
      id: id,
      componentType: componentType,
      position: position,
      config: config
    };
  }
}

function connectionToJson(conn) {
  return Js_dict.fromArray([
    [
      "id",
      conn.id
    ],
    [
      "from",
      conn.from
    ],
    [
      "to",
      conn.to
    ]
  ]);
}

function connectionFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let id = Belt_Option.flatMap(Js_dict.get(obj$1, "id"), Js_json.decodeString);
  let from = Belt_Option.flatMap(Js_dict.get(obj$1, "from"), Js_json.decodeString);
  let to = Belt_Option.flatMap(Js_dict.get(obj$1, "to"), Js_json.decodeString);
  if (id !== undefined && from !== undefined && to !== undefined) {
    return {
      id: id,
      from: from,
      to: to
    };
  }
}

function modelToJson(model) {
  return Js_dict.fromArray([
    [
      "components",
      Belt_Array.map(model.components, componentToJson)
    ],
    [
      "connections",
      Belt_Array.map(model.connections, connectionToJson)
    ]
  ]);
}

function modelFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let components = Belt_Option.flatMap(Js_dict.get(obj$1, "components"), arr => {
    let items = Js_json.classify(arr);
    if (typeof items !== "object" || items.TAG !== "JSONArray") {
      return;
    } else {
      return Belt_Array.keepMap(Belt_Array.map(items._0, componentFromJson), x => x);
    }
  });
  let connections = Belt_Option.flatMap(Js_dict.get(obj$1, "connections"), arr => {
    let items = Js_json.classify(arr);
    if (typeof items !== "object" || items.TAG !== "JSONArray") {
      return;
    } else {
      return Belt_Array.keepMap(Belt_Array.map(items._0, connectionFromJson), x => x);
    }
  });
  if (components !== undefined && connections !== undefined) {
    return {
      components: components,
      connections: connections,
      selectedComponent: Model.initialModel.selectedComponent,
      dragState: Model.initialModel.dragState,
      canvasOffset: Model.initialModel.canvasOffset,
      zoomLevel: Model.initialModel.zoomLevel,
      validationResult: Model.initialModel.validationResult
    };
  }
}

function serializeDesign(model, metadata) {
  return JSON.stringify(Js_dict.fromArray([
    [
      "version",
      metadata.version
    ],
    [
      "metadata",
      Js_dict.fromArray([
        [
          "created",
          metadata.created
        ],
        [
          "author",
          metadata.author
        ],
        [
          "description",
          metadata.description
        ]
      ])
    ],
    [
      "canvas",
      modelToJson(model)
    ]
  ]));
}

function deserializeDesign(jsonStr) {
  try {
    let json = JSON.parse(jsonStr);
    let obj = Js_json.classify(json);
    if (typeof obj !== "object") {
      return {
        TAG: "Error",
        _0: "Design file must be a JSON object"
      };
    }
    if (obj.TAG !== "JSONObject") {
      return {
        TAG: "Error",
        _0: "Design file must be a JSON object"
      };
    }
    let obj$1 = obj._0;
    let version = Belt_Option.flatMap(Js_dict.get(obj$1, "version"), Js_json.decodeString);
    let metadata = Belt_Option.flatMap(Js_dict.get(obj$1, "metadata"), metaJson => {
      let metaObj = Js_json.classify(metaJson);
      if (typeof metaObj !== "object") {
        return;
      }
      if (metaObj.TAG !== "JSONObject") {
        return;
      }
      let metaObj$1 = metaObj._0;
      let created = Belt_Option.flatMap(Js_dict.get(metaObj$1, "created"), Js_json.decodeString);
      let author = Belt_Option.flatMap(Js_dict.get(metaObj$1, "author"), Js_json.decodeString);
      let description = Belt_Option.flatMap(Js_dict.get(metaObj$1, "description"), Js_json.decodeString);
      if (created !== undefined && author !== undefined && description !== undefined) {
        return {
          version: Belt_Option.getWithDefault(version, "1.0"),
          created: created,
          author: author,
          description: description
        };
      }
    });
    let canvas = Belt_Option.flatMap(Js_dict.get(obj$1, "canvas"), modelFromJson);
    if (metadata !== undefined && canvas !== undefined) {
      return {
        TAG: "Ok",
        _0: [
          metadata,
          canvas
        ]
      };
    } else {
      return {
        TAG: "Error",
        _0: "Invalid design file structure"
      };
    }
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: "JSON parse error: " + Belt_Option.getWithDefault(e._1.message, "Unknown error")
      };
    }
    throw e;
  }
}

let currentVersion = "1.0";

export {
  currentVersion,
  componentToJson,
  componentFromJson,
  connectionToJson,
  connectionFromJson,
  modelToJson,
  modelFromJson,
  serializeDesign,
  deserializeDesign,
}
/* No side effect */
