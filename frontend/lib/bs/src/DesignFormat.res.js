// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Model from "./Model.res.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as Stdlib_JsExn from "@rescript/runtime/lib/es6/Stdlib_JsExn.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function componentToJson(comp) {
  let configJson = Object.fromEntries(Belt_Array.map(Object.entries(comp.config), param => [
    param[0],
    param[1]
  ]));
  return Object.fromEntries([
    [
      "id",
      comp.id
    ],
    [
      "type",
      Model.componentTypeToString(comp.componentType)
    ],
    [
      "position",
      Object.fromEntries([
        [
          "x",
          comp.position.x
        ],
        [
          "y",
          comp.position.y
        ]
      ])
    ],
    [
      "config",
      configJson
    ]
  ]);
}

function componentFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let id = Belt_Option.flatMap(obj$1["id"], Stdlib_JSON.Decode.string);
  let typeStr = Belt_Option.flatMap(obj$1["type"], Stdlib_JSON.Decode.string);
  let position = Belt_Option.flatMap(obj$1["position"], posJson => {
    let posObj = Js_json.classify(posJson);
    if (typeof posObj !== "object") {
      return;
    }
    if (posObj.TAG !== "JSONObject") {
      return;
    }
    let posObj$1 = posObj._0;
    let x = Belt_Option.flatMap(posObj$1["x"], Stdlib_JSON.Decode.float);
    let y = Belt_Option.flatMap(posObj$1["y"], Stdlib_JSON.Decode.float);
    if (x !== undefined && y !== undefined) {
      return {
        x: x,
        y: y
      };
    }
  });
  let config = Belt_Option.flatMap(obj$1["config"], cfg => {
    let dict = Js_json.classify(cfg);
    if (typeof dict !== "object") {
      return;
    }
    if (dict.TAG !== "JSONObject") {
      return;
    }
    let stringDict = {};
    Belt_Array.forEach(Object.entries(dict._0), param => {
      let str = Stdlib_JSON.Decode.string(param[1]);
      if (str !== undefined) {
        stringDict[param[0]] = str;
        return;
      }
    });
    return stringDict;
  });
  let componentType;
  if (typeStr !== undefined) {
    switch (typeStr) {
      case "Cerro Torre" :
        componentType = "CerroTorre";
        break;
      case "Docker" :
        componentType = "Docker";
        break;
      case "Lago Grey" :
        componentType = "LagoGrey";
        break;
      case "Network" :
        componentType = "Network";
        break;
      case "Podman" :
        componentType = "Podman";
        break;
      case "Svalinn" :
        componentType = "Svalinn";
        break;
      case "Volume" :
        componentType = "Volume";
        break;
      case "Vörðr" :
        componentType = "Vordr";
        break;
      case "nerdctl" :
        componentType = "Nerdctl";
        break;
      case "selur" :
        componentType = "Selur";
        break;
      default:
        componentType = undefined;
    }
  } else {
    componentType = undefined;
  }
  if (id !== undefined && componentType !== undefined && position !== undefined && config !== undefined) {
    return {
      id: id,
      componentType: componentType,
      position: position,
      config: config
    };
  }
}

function connectionToJson(conn) {
  return Object.fromEntries([
    [
      "id",
      conn.id
    ],
    [
      "from",
      conn.from
    ],
    [
      "to",
      conn.to
    ]
  ]);
}

function connectionFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let id = Belt_Option.flatMap(obj$1["id"], Stdlib_JSON.Decode.string);
  let from = Belt_Option.flatMap(obj$1["from"], Stdlib_JSON.Decode.string);
  let to = Belt_Option.flatMap(obj$1["to"], Stdlib_JSON.Decode.string);
  if (id !== undefined && from !== undefined && to !== undefined) {
    return {
      id: id,
      from: from,
      to: to
    };
  }
}

function modelToJson(model) {
  return Object.fromEntries([
    [
      "components",
      Belt_Array.map(model.components, componentToJson)
    ],
    [
      "connections",
      Belt_Array.map(model.connections, connectionToJson)
    ]
  ]);
}

function modelFromJson(json) {
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return;
  }
  if (obj.TAG !== "JSONObject") {
    return;
  }
  let obj$1 = obj._0;
  let components = Belt_Option.flatMap(obj$1["components"], arr => {
    let items = Js_json.classify(arr);
    if (typeof items !== "object" || items.TAG !== "JSONArray") {
      return;
    } else {
      return Belt_Array.keepMap(Belt_Array.map(items._0, componentFromJson), x => x);
    }
  });
  let connections = Belt_Option.flatMap(obj$1["connections"], arr => {
    let items = Js_json.classify(arr);
    if (typeof items !== "object" || items.TAG !== "JSONArray") {
      return;
    } else {
      return Belt_Array.keepMap(Belt_Array.map(items._0, connectionFromJson), x => x);
    }
  });
  if (components !== undefined && connections !== undefined) {
    return {
      components: components,
      connections: connections,
      selectedComponent: Model.initialModel.selectedComponent,
      dragState: Model.initialModel.dragState,
      canvasOffset: Model.initialModel.canvasOffset,
      zoomLevel: Model.initialModel.zoomLevel,
      validationResult: Model.initialModel.validationResult
    };
  }
}

function serializeDesign(model, metadata) {
  let design = Object.fromEntries([
    [
      "version",
      metadata.version
    ],
    [
      "metadata",
      Object.fromEntries([
        [
          "created",
          metadata.created
        ],
        [
          "author",
          metadata.author
        ],
        [
          "description",
          metadata.description
        ]
      ])
    ],
    [
      "canvas",
      modelToJson(model)
    ]
  ]);
  return JSON.stringify(design);
}

function deserializeDesign(jsonStr) {
  try {
    let json = JSON.parse(jsonStr);
    let obj = Js_json.classify(json);
    if (typeof obj !== "object") {
      return {
        TAG: "Error",
        _0: "Design file must be a JSON object"
      };
    }
    if (obj.TAG !== "JSONObject") {
      return {
        TAG: "Error",
        _0: "Design file must be a JSON object"
      };
    }
    let obj$1 = obj._0;
    let version = Belt_Option.flatMap(obj$1["version"], Stdlib_JSON.Decode.string);
    let metadata = Belt_Option.flatMap(obj$1["metadata"], metaJson => {
      let metaObj = Js_json.classify(metaJson);
      if (typeof metaObj !== "object") {
        return;
      }
      if (metaObj.TAG !== "JSONObject") {
        return;
      }
      let metaObj$1 = metaObj._0;
      let created = Belt_Option.flatMap(metaObj$1["created"], Stdlib_JSON.Decode.string);
      let author = Belt_Option.flatMap(metaObj$1["author"], Stdlib_JSON.Decode.string);
      let description = Belt_Option.flatMap(metaObj$1["description"], Stdlib_JSON.Decode.string);
      if (created !== undefined && author !== undefined && description !== undefined) {
        return {
          version: Belt_Option.getWithDefault(version, "1.0"),
          created: created,
          author: author,
          description: description
        };
      }
    });
    let canvas = Belt_Option.flatMap(obj$1["canvas"], modelFromJson);
    if (metadata !== undefined && canvas !== undefined) {
      return {
        TAG: "Ok",
        _0: [
          metadata,
          canvas
        ]
      };
    } else {
      return {
        TAG: "Error",
        _0: "Invalid design file structure"
      };
    }
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === "JsExn") {
      return {
        TAG: "Error",
        _0: "JSON parse error: " + Belt_Option.getWithDefault(Stdlib_JsExn.message(e._1), "Unknown error")
      };
    }
    throw e;
  }
}

let currentVersion = "1.0";

export {
  currentVersion,
  componentToJson,
  componentFromJson,
  connectionToJson,
  connectionFromJson,
  modelToJson,
  modelFromJson,
  serializeDesign,
  deserializeDesign,
}
/* Stdlib_JsExn Not a pure module */
