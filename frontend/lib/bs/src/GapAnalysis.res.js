// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as JsxRuntime from "react/jsx-runtime";

let init_gaps = [
  {
    id: "gap-1",
    title: "Missing health check endpoints",
    category: "Reliability",
    severity: "High",
    description: "None of the services have configured health check endpoints. This prevents proper monitoring and automated recovery.",
    impact: "Cannot detect service failures automatically. Increased downtime risk.",
    source: "AutomatedScan",
    scope: "EntireStack",
    affectedComponents: [
      "node-1",
      "node-2",
      "node-3"
    ],
    fixAvailable: true,
    fixConfidence: "High",
    fixDescription: "Add /health endpoints to all services. Configure readiness and liveness probes.",
    fixCommands: [
      "Add health check route to application code",
      "Update stack.yaml with healthcheck configuration",
      "Configure Dustfile recovery strategy"
    ],
    estimatedEffort: "15 minutes",
    tags: [
      "monitoring",
      "reliability",
      "k8s"
    ]
  },
  {
    id: "gap-2",
    title: "Unencrypted database connection",
    category: "Security",
    severity: "Critical",
    description: "Connection from Auth Service to PostgreSQL is not encrypted with TLS. Database credentials and query results transmitted in cleartext.",
    impact: "Sensitive data exposure. Violates compliance requirements (GDPR, HIPAA).",
    source: "MiniKanrenReasoning",
    scope: {
      TAG: "SingleComponent",
      _0: "conn-2"
    },
    affectedComponents: [
      "node-2",
      "node-3"
    ],
    fixAvailable: true,
    fixConfidence: "Verified",
    fixDescription: "Enable TLS on PostgreSQL connection. Generate TLS certificates. Update connection string.",
    fixCommands: [
      "Generate TLS certificates with Ed448",
      "Configure PostgreSQL to require SSL",
      "Update connection string: postgresql://...?sslmode=require",
      "Mount certificates in containers"
    ],
    estimatedEffort: "30 minutes",
    tags: [
      "encryption",
      "compliance",
      "database"
    ]
  },
  {
    id: "gap-3",
    title: "Container running as root",
    category: "Security",
    severity: "High",
    description: "Auth Service container runs as root user (UID 0). Violates principle of least privilege.",
    impact: "Container escape could lead to host compromise. Elevated privilege risk.",
    source: "AutomatedScan",
    scope: {
      TAG: "SingleComponent",
      _0: "node-2"
    },
    affectedComponents: ["node-2"],
    fixAvailable: true,
    fixConfidence: "High",
    fixDescription: "Add USER directive to Containerfile. Create non-privileged user with minimal permissions.",
    fixCommands: [
      "Add to Containerfile: RUN adduser -D appuser",
      "Add to Containerfile: USER appuser",
      "Rebuild container image"
    ],
    estimatedEffort: "10 minutes",
    tags: [
      "least-privilege",
      "hardening"
    ]
  },
  {
    id: "gap-4",
    title: "Missing resource limits",
    category: "Performance",
    severity: "Medium",
    description: "PostgreSQL container has no CPU or memory limits. Could monopolize host resources.",
    impact: "Risk of resource starvation for other services. Unpredictable performance.",
    source: "CIWorkflow",
    scope: {
      TAG: "SingleComponent",
      _0: "node-3"
    },
    affectedComponents: ["node-3"],
    fixAvailable: true,
    fixConfidence: "Medium",
    fixDescription: "Add resource limits to stack.yaml. Recommended: 2 CPU, 4GB memory.",
    fixCommands: [
      "Update stack.yaml with deploy.resources.limits",
      "Test with realistic workload",
      "Adjust limits based on monitoring"
    ],
    estimatedEffort: "20 minutes",
    tags: [
      "resources",
      "performance"
    ]
  },
  {
    id: "gap-5",
    title: "No rate limiting on API Gateway",
    category: "Security",
    severity: "High",
    description: "API Gateway has no rate limiting configured. Vulnerable to DDoS and brute force attacks.",
    impact: "Service availability risk. Increased infrastructure costs from abuse.",
    source: "HypatiaAgent",
    scope: {
      TAG: "SingleComponent",
      _0: "node-1"
    },
    affectedComponents: ["node-1"],
    fixAvailable: true,
    fixConfidence: "High",
    fixDescription: "Configure nginx rate limiting. Recommended: 100 req/min per IP.",
    fixCommands: [
      "Add limit_req_zone to nginx.conf",
      "Configure burst and nodelay parameters",
      "Add rate limit headers to responses"
    ],
    estimatedEffort: "25 minutes",
    tags: [
      "ddos",
      "rate-limiting",
      "nginx"
    ]
  },
  {
    id: "gap-6",
    title: "Missing SBOM generation",
    category: "Compliance",
    severity: "Medium",
    description: "No Software Bill of Materials (SBOM) generated for container images. Required for supply chain security.",
    impact: "Cannot track vulnerabilities in dependencies. Violates supply chain policy.",
    source: "VeriSimDBQuery",
    scope: "EntireStack",
    affectedComponents: [
      "node-1",
      "node-2",
      "node-3"
    ],
    fixAvailable: true,
    fixConfidence: "Verified",
    fixDescription: "Add syft to build pipeline. Generate CycloneDX SBOMs for all images.",
    fixCommands: [
      "Install syft: curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh",
      "Add to Justfile: syft <image> -o cyclonedx-json > sbom.json",
      "Sign SBOMs with Ed448+Dilithium5",
      "Upload to VeriSimDB"
    ],
    estimatedEffort: "45 minutes",
    tags: [
      "sbom",
      "supply-chain",
      "compliance"
    ]
  }
];

let init = {
  gaps: init_gaps,
  appliedFixes: undefined,
  selectedGap: undefined,
  filterCategory: undefined,
  filterSeverity: undefined,
  showOnlyFixable: false,
  sortBy: "BySeverity"
};

function update(msg, state) {
  if (typeof msg !== "object") {
    switch (msg) {
      case "ToggleShowOnlyFixable" :
        return {
          gaps: state.gaps,
          appliedFixes: state.appliedFixes,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: !state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "RunGapAnalysis" :
        return state;
      case "ApplyAllAutoFixes" :
        let updatedFixes = Belt_Array.reduce(state.gaps, state.appliedFixes, (fixes, gap) => {
          if (gap.fixAvailable && (gap.fixConfidence === "Verified" || gap.fixConfidence === "High")) {
            return Belt_MapString.set(fixes, gap.id, "Applied");
          } else {
            return fixes;
          }
        });
        return {
          gaps: state.gaps,
          appliedFixes: updatedFixes,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
    }
  } else {
    switch (msg.TAG) {
      case "SelectGap" :
        return {
          gaps: state.gaps,
          appliedFixes: state.appliedFixes,
          selectedGap: msg._0,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "ApplyFix" :
        let gapId = msg._0;
        let updatedFixes$1 = Belt_MapString.set(state.appliedFixes, gapId, "InProgress");
        let finalFixes = Belt_MapString.set(updatedFixes$1, gapId, "Applied");
        return {
          gaps: state.gaps,
          appliedFixes: finalFixes,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "VerifyFix" :
        let updatedFixes$2 = Belt_MapString.set(state.appliedFixes, msg._0, "Verified");
        return {
          gaps: state.gaps,
          appliedFixes: updatedFixes$2,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "FilterByCategory" :
        return {
          gaps: state.gaps,
          appliedFixes: state.appliedFixes,
          selectedGap: state.selectedGap,
          filterCategory: msg._0,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "FilterBySeverity" :
        return {
          gaps: state.gaps,
          appliedFixes: state.appliedFixes,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: msg._0,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: state.sortBy
        };
      case "ChangeSortOrder" :
        return {
          gaps: state.gaps,
          appliedFixes: state.appliedFixes,
          selectedGap: state.selectedGap,
          filterCategory: state.filterCategory,
          filterSeverity: state.filterSeverity,
          showOnlyFixable: state.showOnlyFixable,
          sortBy: msg._0
        };
    }
  }
}

function categoryColor(category) {
  switch (category) {
    case "Security" :
      return "#f44336";
    case "Compliance" :
      return "#9c27b0";
    case "Performance" :
      return "#4caf50";
    case "Reliability" :
      return "#2196f3";
    case "BestPractice" :
      return "#ff9800";
  }
}

function categoryLabel(category) {
  switch (category) {
    case "Security" :
      return "Security";
    case "Compliance" :
      return "Compliance";
    case "Performance" :
      return "Performance";
    case "Reliability" :
      return "Reliability";
    case "BestPractice" :
      return "Best Practice";
  }
}

function severityColor(severity) {
  switch (severity) {
    case "Critical" :
      return "#d32f2f";
    case "High" :
      return "#f57c00";
    case "Medium" :
      return "#fbc02d";
    case "Low" :
      return "#388e3c";
  }
}

function severityLabel(severity) {
  switch (severity) {
    case "Critical" :
      return "Critical";
    case "High" :
      return "High";
    case "Medium" :
      return "Medium";
    case "Low" :
      return "Low";
  }
}

function sourceIcon(source) {
  if (typeof source === "object") {
    return "ðŸ”§";
  }
  switch (source) {
    case "ManualReview" :
      return "ðŸ‘¤";
    case "CIWorkflow" :
      return "ðŸ”„";
    case "MiniKanrenReasoning" :
      return "ðŸ§ ";
    case "VeriSimDBQuery" :
      return "ðŸ—„ï¸";
    case "AutomatedScan" :
    case "HypatiaAgent" :
      return "ðŸ¤–";
  }
}

function sourceLabel(source) {
  if (typeof source === "object") {
    return source._0;
  }
  switch (source) {
    case "ManualReview" :
      return "Manual Review";
    case "AutomatedScan" :
      return "Automated Scan";
    case "CIWorkflow" :
      return "CI Workflow";
    case "MiniKanrenReasoning" :
      return "miniKanren";
    case "VeriSimDBQuery" :
      return "VeriSimDB";
    case "HypatiaAgent" :
      return "Hypatia";
  }
}

function confidenceBadge(confidence) {
  let match;
  switch (confidence) {
    case "Verified" :
      match = [
        "Verified",
        "#4caf50"
      ];
      break;
    case "High" :
      match = [
        "High Confidence",
        "#66bb6a"
      ];
      break;
    case "Medium" :
      match = [
        "Medium Confidence",
        "#ff9800"
      ];
      break;
    case "Low" :
      match = [
        "Low Confidence",
        "#ff5722"
      ];
      break;
    case "Manual" :
      match = [
        "Manual Required",
        "#9e9e9e"
      ];
      break;
  }
  return JsxRuntime.jsx("span", {
    children: match[0],
    style: {
      background: match[1],
      color: "white",
      fontSize: "11px",
      fontWeight: "700",
      padding: "4px 10px",
      borderRadius: "6px"
    }
  });
}

function fixStatusIcon(status) {
  if (typeof status === "object") {
    return "âŒ";
  }
  switch (status) {
    case "NotStarted" :
      return "â³";
    case "InProgress" :
      return "ðŸ”„";
    case "Applied" :
      return "âœ…";
    case "Verified" :
      return "ðŸ”";
  }
}

function viewGap(gap, fixStatus, dispatch) {
  let tmp;
  if (gap.fixAvailable) {
    let desc = gap.fixDescription;
    let commands = gap.fixCommands;
    let tmp$1;
    let exit = 0;
    if (fixStatus !== undefined && typeof fixStatus !== "object") {
      switch (fixStatus) {
        case "Applied" :
        case "Verified" :
          exit = 2;
          break;
        default:
          exit = 1;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
        tmp$1 = JsxRuntime.jsx("button", {
          children: "ðŸ”§ Apply Fix",
          style: {
            background: "linear-gradient(135deg, #4caf50, #66bb6a)",
            border: "none",
            color: "white",
            cursor: "pointer",
            fontSize: "13px",
            fontWeight: "600",
            padding: "10px 20px",
            borderRadius: "8px"
          },
          onClick: e => {
            e.stopPropagation();
            dispatch({
              TAG: "ApplyFix",
              _0: gap.id
            });
          }
        });
        break;
      case 2 :
        tmp$1 = JsxRuntime.jsx("button", {
          children: "âœ“ Fix Applied",
          style: {
            background: "#4caf50",
            border: "none",
            color: "white",
            cursor: "not-allowed",
            fontSize: "13px",
            fontWeight: "600",
            padding: "10px 20px",
            opacity: "0.7",
            borderRadius: "8px"
          },
          disabled: true
        });
        break;
    }
    let tmp$2;
    tmp$2 = fixStatus === "Applied" && typeof fixStatus !== "object" ? JsxRuntime.jsx("button", {
        children: "ðŸ” Verify Fix",
        style: {
          background: "linear-gradient(135deg, #2196f3, #42a5f5)",
          border: "none",
          color: "white",
          cursor: "pointer",
          fontSize: "13px",
          fontWeight: "600",
          padding: "10px 20px",
          borderRadius: "8px"
        },
        onClick: e => {
          e.stopPropagation();
          dispatch({
            TAG: "VerifyFix",
            _0: gap.id
          });
        }
      }) : null;
    tmp = JsxRuntime.jsxs("div", {
      children: [
        desc !== undefined ? JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("strong", {
                children: "Fix: ",
                style: {
                  color: "#4caf50",
                  fontSize: "12px"
                }
              }),
              JsxRuntime.jsx("span", {
                children: desc,
                style: {
                  color: "#b0b8c4",
                  fontSize: "12px"
                }
              })
            ],
            style: {
              background: "rgba(76, 175, 80, 0.1)",
              border: "1px solid #4caf50",
              marginBottom: "12px",
              padding: "12px",
              borderRadius: "8px"
            }
          }) : null,
        commands !== undefined ? JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("div", {
                children: "Steps:",
                style: {
                  color: "#8892a6",
                  fontSize: "12px",
                  fontWeight: "600",
                  marginBottom: "6px"
                }
              }),
              JsxRuntime.jsx("ol", {
                children: Belt_Array.map(commands, cmd => JsxRuntime.jsx("li", {
                  children: cmd
                }, cmd)),
                style: {
                  color: "#b0b8c4",
                  fontSize: "12px",
                  lineHeight: "1.8",
                  paddingLeft: "20px"
                }
              })
            ],
            style: {
              marginBottom: "12px"
            }
          }) : null,
        JsxRuntime.jsxs("div", {
          children: [
            tmp$1,
            tmp$2
          ],
          style: {
            display: "flex",
            gap: "8px"
          }
        })
      ]
    });
  } else {
    tmp = JsxRuntime.jsx("div", {
      children: "âš ï¸ No automated fix available. Manual remediation required.",
      style: {
        background: "rgba(158, 158, 158, 0.1)",
        border: "1px solid #9e9e9e",
        color: "#9e9e9e",
        fontSize: "12px",
        padding: "12px",
        borderRadius: "8px"
      }
    });
  }
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("span", {
                  children: categoryLabel(gap.category),
                  style: {
                    background: categoryColor(gap.category),
                    color: "white",
                    fontSize: "11px",
                    fontWeight: "700",
                    padding: "4px 12px",
                    borderRadius: "6px"
                  }
                }),
                JsxRuntime.jsx("span", {
                  children: severityLabel(gap.severity),
                  style: {
                    background: severityColor(gap.severity),
                    color: "white",
                    fontSize: "11px",
                    fontWeight: "700",
                    padding: "4px 12px",
                    borderRadius: "6px"
                  }
                }),
                gap.fixAvailable ? confidenceBadge(gap.fixConfidence) : null,
                fixStatus !== undefined ? JsxRuntime.jsx("span", {
                    children: fixStatusIcon(fixStatus),
                    style: {
                      fontSize: "18px"
                    }
                  }) : null
              ],
              style: {
                display: "flex",
                marginBottom: "8px",
                flexWrap: "wrap",
                gap: "8px"
              }
            }),
            JsxRuntime.jsx("h3", {
              children: gap.title,
              style: {
                color: "#e0e6ed",
                fontSize: "18px",
                fontWeight: "700",
                marginBottom: "8px"
              }
            })
          ],
          style: {
            flex: "1"
          }
        }),
        style: {
          display: "flex",
          marginBottom: "12px",
          alignItems: "flex-start",
          justifyContent: "space-between"
        }
      }),
      JsxRuntime.jsx("p", {
        children: gap.description,
        style: {
          color: "#8892a6",
          fontSize: "13px",
          lineHeight: "1.6",
          marginBottom: "12px"
        }
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("strong", {
            children: "Impact: ",
            style: {
              color: "#f44336",
              fontSize: "12px"
            }
          }),
          JsxRuntime.jsx("span", {
            children: gap.impact,
            style: {
              color: "#b0b8c4",
              fontSize: "12px"
            }
          })
        ],
        style: {
          background: "rgba(244, 67, 54, 0.1)",
          border: "1px solid #f44336",
          marginBottom: "12px",
          padding: "12px",
          borderRadius: "8px"
        }
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("span", {
                children: sourceIcon(gap.source),
                style: {
                  marginRight: "6px"
                }
              }),
              JsxRuntime.jsx("strong", {
                children: sourceLabel(gap.source),
                style: {
                  color: "#4a9eff"
                }
              })
            ],
            style: {
              color: "#8892a6",
              fontSize: "12px"
            }
          }),
          JsxRuntime.jsxs("div", {
            children: [
              "Affects: ",
              JsxRuntime.jsxs("strong", {
                children: [
                  String(gap.affectedComponents.length),
                  " component",
                  gap.affectedComponents.length !== 1 ? "s" : null
                ],
                style: {
                  color: "#ff9800"
                }
              })
            ],
            style: {
              color: "#8892a6",
              fontSize: "12px"
            }
          }),
          JsxRuntime.jsxs("div", {
            children: [
              "â±ï¸ ",
              JsxRuntime.jsx("strong", {
                children: gap.estimatedEffort,
                style: {
                  color: "#4caf50"
                }
              })
            ],
            style: {
              color: "#8892a6",
              fontSize: "12px"
            }
          })
        ],
        style: {
          display: "flex",
          marginBottom: "16px",
          flexWrap: "wrap",
          gap: "24px"
        }
      }),
      JsxRuntime.jsx("div", {
        children: Belt_Array.map(gap.tags, tag => JsxRuntime.jsxs("span", {
          children: [
            "#",
            tag
          ],
          style: {
            background: "#2a3142",
            color: "#8892a6",
            fontSize: "10px",
            fontWeight: "600",
            padding: "3px 8px",
            borderRadius: "4px"
          }
        }, tag)),
        style: {
          display: "flex",
          marginBottom: "16px",
          flexWrap: "wrap",
          gap: "6px"
        }
      }),
      tmp
    ],
    style: {
      background: "linear-gradient(135deg, #1e2431 0%, #252d3d 100%)",
      border: "2px solid #2a3142",
      cursor: "pointer",
      marginBottom: "16px",
      padding: "20px",
      borderRadius: "12px",
      transition: "all 0.2s"
    },
    onClick: param => dispatch({
      TAG: "SelectGap",
      _0: gap.id
    })
  }, gap.id);
}

function GapAnalysis(props) {
  let onStateChange = props.onStateChange;
  let initialState = props.initialState;
  let match = React.useState(() => {
    if (initialState !== undefined) {
      return initialState;
    } else {
      return init;
    }
  });
  let setState = match[1];
  let state = match[0];
  let dispatch = msg => {
    let newState = update(msg, state);
    setState(param => newState);
    if (onStateChange !== undefined) {
      return onStateChange(newState);
    }
  };
  let filteredGaps = Belt_Array.reduce(state.gaps, [], (acc, gap) => {
    let cat = state.filterCategory;
    let matchesCategory = cat !== undefined ? gap.category === cat : true;
    let sev = state.filterSeverity;
    let matchesSeverity = sev !== undefined ? gap.severity === sev : true;
    let matchesFixable = !state.showOnlyFixable || gap.fixAvailable;
    if (matchesCategory && matchesSeverity && matchesFixable) {
      return Belt_Array.concat(acc, [gap]);
    } else {
      return acc;
    }
  });
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("h1", {
            children: "ðŸ” Gap Analysis",
            style: {
              background: "linear-gradient(135deg, #4a9eff, #7b6cff)",
              fontSize: "32px",
              fontWeight: "700",
              marginBottom: "8px"
            }
          }),
          JsxRuntime.jsx("p", {
            children: "Automated detection and remediation of security and compliance gaps",
            style: {
              color: "#8892a6",
              fontSize: "16px"
            }
          })
        ],
        style: {
          marginBottom: "32px"
        }
      }),
      JsxRuntime.jsx("div", {
        children: Belt_Array.map([
          [
            "Total Gaps",
            String(state.gaps.length),
            "#4a9eff"
          ],
          [
            "Critical",
            String(Belt_Array.reduce(state.gaps, 0, (acc, g) => {
              if (g.severity === "Critical") {
                return acc + 1 | 0;
              } else {
                return acc;
              }
            })),
            "#f44336"
          ],
          [
            "Auto-Fixable",
            String(Belt_Array.reduce(state.gaps, 0, (acc, g) => {
              if (g.fixAvailable) {
                return acc + 1 | 0;
              } else {
                return acc;
              }
            })),
            "#4caf50"
          ],
          [
            "Applied",
            String(Belt_MapString.size(state.appliedFixes)),
            "#ff9800"
          ]
        ], param => {
          let label = param[0];
          return JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("div", {
                children: param[1],
                style: {
                  color: param[2],
                  fontSize: "36px",
                  fontWeight: "700",
                  marginBottom: "8px"
                }
              }),
              JsxRuntime.jsx("div", {
                children: label,
                style: {
                  color: "#8892a6",
                  fontSize: "13px"
                }
              })
            ],
            style: {
              background: "linear-gradient(135deg, #1e2431 0%, #252d3d 100%)",
              border: "2px solid #2a3142",
              padding: "20px",
              textAlign: "center",
              borderRadius: "12px"
            }
          }, label);
        }),
        style: {
          display: "grid",
          marginBottom: "32px",
          gap: "16px",
          gridTemplateColumns: "repeat(4, 1fr)"
        }
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("button", {
                children: "ðŸ” Run Analysis",
                style: {
                  background: "linear-gradient(135deg, #4a9eff, #7b6cff)",
                  border: "none",
                  color: "white",
                  cursor: "pointer",
                  fontSize: "14px",
                  fontWeight: "600",
                  padding: "10px 20px",
                  borderRadius: "8px"
                },
                onClick: param => dispatch("RunGapAnalysis")
              }),
              JsxRuntime.jsx("button", {
                children: "âš¡ Apply All Auto-Fixes",
                style: {
                  background: "linear-gradient(135deg, #4caf50, #66bb6a)",
                  border: "none",
                  color: "white",
                  cursor: "pointer",
                  fontSize: "14px",
                  fontWeight: "600",
                  padding: "10px 20px",
                  borderRadius: "8px"
                },
                onClick: param => dispatch("ApplyAllAutoFixes")
              })
            ],
            style: {
              display: "flex",
              gap: "12px"
            }
          }),
          JsxRuntime.jsxs("label", {
            children: [
              JsxRuntime.jsx("input", {
                checked: state.showOnlyFixable,
                type: "checkbox",
                onChange: param => dispatch("ToggleShowOnlyFixable")
              }),
              "Show only fixable"
            ],
            style: {
              color: "#8892a6",
              cursor: "pointer",
              display: "flex",
              fontSize: "13px",
              alignItems: "center",
              gap: "8px"
            }
          })
        ],
        style: {
          background: "linear-gradient(135deg, #1e2431 0%, #252d3d 100%)",
          border: "2px solid #2a3142",
          display: "flex",
          marginBottom: "24px",
          padding: "16px",
          borderRadius: "12px",
          alignItems: "center",
          justifyContent: "space-between"
        }
      }),
      JsxRuntime.jsx("div", {
        children: filteredGaps.length !== 0 ? Belt_Array.map(filteredGaps, gap => viewGap(gap, Belt_MapString.get(state.appliedFixes, gap.id), dispatch)) : JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("div", {
                children: "âœ…",
                style: {
                  fontSize: "64px",
                  marginBottom: "16px"
                }
              }),
              JsxRuntime.jsx("div", {
                children: "No Gaps Detected",
                style: {
                  color: "#4caf50",
                  fontSize: "24px",
                  fontWeight: "700",
                  marginBottom: "12px"
                }
              }),
              JsxRuntime.jsx("div", {
                children: "Your stack meets all security, compliance, and best practice requirements",
                style: {
                  color: "#8892a6",
                  fontSize: "16px"
                }
              })
            ],
            style: {
              background: "rgba(76, 175, 80, 0.1)",
              border: "2px solid #4caf50",
              padding: "60px",
              textAlign: "center",
              borderRadius: "16px"
            }
          })
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("h4", {
            children: "ðŸ¤– AI-Powered Gap Analysis",
            style: {
              color: "#4a9eff",
              fontSize: "16px",
              fontWeight: "700",
              marginBottom: "12px"
            }
          }),
          JsxRuntime.jsx("p", {
            children: "Gap detection powered by miniKanren reasoning engine, Hypatia neurosymbolic agent, and VeriSimDB historical analysis. Fixes verified with formal proofs before application. All changes logged to compliance audit trail.",
            style: {
              color: "#b0b8c4",
              fontSize: "13px",
              lineHeight: "1.8"
            }
          })
        ],
        style: {
          background: "rgba(74, 158, 255, 0.1)",
          border: "2px solid #4a9eff",
          marginTop: "32px",
          padding: "20px",
          borderRadius: "12px"
        }
      })
    ],
    className: "gap-analysis",
    style: {
      background: "#0a0e1a",
      minHeight: "100vh",
      padding: "32px"
    }
  });
}

let make = GapAnalysis;

export {
  init,
  update,
  categoryColor,
  categoryLabel,
  severityColor,
  severityLabel,
  sourceIcon,
  sourceLabel,
  confidenceBadge,
  fixStatusIcon,
  viewGap,
  make,
}
/* react Not a pure module */
