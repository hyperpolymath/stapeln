// Generated by ReScript, PLEASE EDIT WITH CARE


function errorToUserMessage(error) {
  switch (error.TAG) {
    case "ElementNotFound" :
      let id = error._0;
      return `Element with ID "` + id + `" not found. Check your HTML for <div id="` + id + `"></div>`;
    case "InvalidElementId" :
      return `Element ID "` + error._0 + `" is invalid. IDs must be non-empty alphanumeric strings (with dash/underscore allowed).`;
    case "ElementAlreadyMounted" :
      return `Element "` + error._0 + `" already has content. Use unmount() first or choose a different element.`;
    case "ParentNotFound" :
      return `Cannot find parent element for "` + error._0 + `". Ensure the element is in the document.`;
    case "PermissionDenied" :
      return `Permission denied mounting to "` + error._0 + `". This may be a protected or restricted element.`;
    case "HealthCheckFailed" :
      return `Health check failed for "` + error._0 + `": ` + error._1 + `. The element may not be suitable for mounting.`;
  }
}

let defaultHooks = {
  beforeMount: undefined,
  afterMount: undefined,
  beforeUnmount: undefined,
  afterUnmount: undefined,
  onError: undefined
};

function healthStatusFromInt(code) {
  if (code !== 0) {
    if (code !== 1) {
      return "Failed";
    } else {
      return "Degraded";
    }
  } else {
    return "Healthy";
  }
}

function lifecycleStageFromInt(code) {
  switch (code) {
    case 0 :
      return "BeforeMount";
    case 1 :
      return "Mounted";
    case 2 :
      return "BeforeUnmount";
    default:
      return "Unmounted";
  }
}

function lifecycleStageToInt(stage) {
  switch (stage) {
    case "BeforeMount" :
      return 0;
    case "Mounted" :
      return 1;
    case "BeforeUnmount" :
      return 2;
    case "Unmounted" :
      return 3;
  }
}

function recoveryResultFromInt(code) {
  switch (code) {
    case 0 :
      return "RecoverySuccess";
    case 1 :
      return "RetryExhausted";
    case 2 :
      return "FallbackFailed";
    default:
      return "CreateFailed";
  }
}

let FFI = {
  healthStatusFromInt: healthStatusFromInt,
  lifecycleStageFromInt: lifecycleStageFromInt,
  lifecycleStageToInt: lifecycleStageToInt,
  recoveryResultFromInt: recoveryResultFromInt
};

function healthCheck(elementId) {
  let code = health_check(elementId);
  let status = healthStatusFromInt(code);
  let message;
  switch (status) {
    case "Healthy" :
      message = "Element ID is valid and healthy";
      break;
    case "Degraded" :
      message = "Element exists but may have issues";
      break;
    case "Failed" :
      message = elementId.length === 0 ? "Element ID is empty" : (
          elementId.length > 255 ? "Element ID is too long (max 255 characters)" : "Element ID contains invalid characters"
        );
      break;
  }
  return [
    status,
    message
  ];
}

function isElementVisible(elementId) {
  let code = is_element_visible(elementId);
  return code === 1;
}

function getLifecycleStage(elementId) {
  return lifecycleStageFromInt(get_element_state(elementId));
}

function canTransitionTo(from, to) {
  let fromInt = lifecycleStageToInt(from);
  let toInt = lifecycleStageToInt(to);
  let result = can_transition(fromInt, toInt);
  return result === 1;
}

function executeRecovery(elementId, _strategy, originalError) {
  while (true) {
    let strategy = _strategy;
    if (typeof strategy !== "object") {
      return {
        TAG: "Error",
        _0: originalError
      };
    }
    if (strategy.TAG === "Retry") {
      let n = strategy._0;
      if (n <= 0) {
        return {
          TAG: "Error",
          _0: originalError
        };
      }
      let code = attempt_retry(elementId, n);
      let result = recoveryResultFromInt(code);
      switch (result) {
        case "RecoverySuccess" :
          return {
            TAG: "Ok",
            _0: elementId
          };
        case "RetryExhausted" :
          if (n <= 1) {
            return {
              TAG: "Error",
              _0: originalError
            };
          }
          _strategy = {
            TAG: "Retry",
            _0: n - 1 | 0
          };
          continue;
        case "FallbackFailed" :
        case "CreateFailed" :
          return {
            TAG: "Error",
            _0: originalError
          };
      }
    } else {
      let fallbackId = strategy._0;
      let code$1 = attempt_fallback(elementId, fallbackId);
      let result$1 = recoveryResultFromInt(code$1);
      switch (result$1) {
        case "RecoverySuccess" :
          return {
            TAG: "Ok",
            _0: fallbackId
          };
        case "FallbackFailed" :
          return {
            TAG: "Error",
            _0: {
              TAG: "ElementNotFound",
              _0: fallbackId
            }
          };
        case "RetryExhausted" :
        case "CreateFailed" :
          return {
            TAG: "Error",
            _0: originalError
          };
      }
    }
  };
}

function mountWithRecovery(elementId, strategy) {
  let match = healthCheck(elementId);
  switch (match[0]) {
    case "Healthy" :
    case "Degraded" :
      return {
        TAG: "Ok",
        _0: elementId
      };
    case "Failed" :
      let error_1 = match[1];
      let error = {
        TAG: "HealthCheckFailed",
        _0: elementId,
        _1: error_1
      };
      return executeRecovery(elementId, strategy, error);
  }
}

function executeHook(hook, arg) {
  if (hook !== undefined) {
    hook(arg);
    return;
  }
}

function executeHookResult(hook, arg) {
  if (hook !== undefined) {
    return hook(arg);
  } else {
    return {
      TAG: "Ok",
      _0: undefined
    };
  }
}

function mountWithLifecycle(elementId, hooks) {
  let e = executeHookResult(hooks.beforeMount, elementId);
  if (e.TAG === "Ok") {
    let match = healthCheck(elementId);
    switch (match[0]) {
      case "Healthy" :
      case "Degraded" :
        break;
      case "Failed" :
        let err = "Health check failed for " + elementId;
        executeHook(hooks.onError, err);
        return {
          TAG: "Error",
          _0: err
        };
    }
    set_element_state(elementId, 1);
    executeHook(hooks.afterMount, elementId);
    return {
      TAG: "Ok",
      _0: undefined
    };
  }
  let e$1 = e._0;
  executeHook(hooks.onError, e$1);
  return {
    TAG: "Error",
    _0: e$1
  };
}

function unmountWithLifecycle(elementId, hooks) {
  executeHook(hooks.beforeUnmount, elementId);
  set_element_state(elementId, 2);
  set_element_state(elementId, 3);
  executeHook(hooks.afterUnmount, elementId);
  return {
    TAG: "Ok",
    _0: undefined
  };
}

function startMonitoring(elementId) {
  let code = start_monitoring(elementId);
  if (code === 0) {
    return {
      TAG: "Ok",
      _0: undefined
    };
  } else {
    return {
      TAG: "Error",
      _0: "Failed to start monitoring for " + elementId
    };
  }
}

function stopMonitoring(elementId) {
  let code = stop_monitoring(elementId);
  if (code === 0) {
    return {
      TAG: "Ok",
      _0: undefined
    };
  } else {
    return {
      TAG: "Error",
      _0: "Failed to stop monitoring for " + elementId
    };
  }
}

function defaultConfig(elementId) {
  return {
    elementId: elementId,
    recovery: {
      TAG: "Retry",
      _0: 3
    },
    lifecycle: defaultHooks,
    monitoring: false
  };
}

function mountEnhanced(config) {
  if (config.monitoring) {
    startMonitoring(config.elementId);
  }
  let strategy = config.recovery;
  if (strategy === undefined) {
    return mountWithLifecycle(config.elementId, config.lifecycle);
  }
  let elementId = mountWithRecovery(config.elementId, strategy);
  if (elementId.TAG === "Ok") {
    return mountWithLifecycle(elementId._0, config.lifecycle);
  }
  let msg = errorToUserMessage(elementId._0);
  executeHook(config.lifecycle.onError, msg);
  return {
    TAG: "Error",
    _0: msg
  };
}

function mount(elementId) {
  return mountEnhanced(defaultConfig(elementId));
}

function mountWith(elementId, beforeMount, afterMount, beforeUnmount, afterUnmount, onError, param) {
  let hooks = {
    beforeMount: beforeMount,
    afterMount: afterMount,
    beforeUnmount: beforeUnmount,
    afterUnmount: afterUnmount,
    onError: onError
  };
  return mountEnhanced({
    elementId: elementId,
    recovery: {
      TAG: "Retry",
      _0: 3
    },
    lifecycle: hooks,
    monitoring: false
  });
}

export {
  errorToUserMessage,
  defaultHooks,
  FFI,
  healthCheck,
  isElementVisible,
  getLifecycleStage,
  canTransitionTo,
  executeRecovery,
  mountWithRecovery,
  executeHook,
  executeHookResult,
  mountWithLifecycle,
  unmountWithLifecycle,
  startMonitoring,
  stopMonitoring,
  defaultConfig,
  mountEnhanced,
  mount,
  mountWith,
}
/* No side effect */
