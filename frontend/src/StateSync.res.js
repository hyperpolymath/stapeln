// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";

function calculatePortSecurityImpact(ports) {
  let openPorts = Belt_Array.reduce(ports, 0, (acc, p) => {
    if (p.state === "Open") {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
  let criticalPortsOpen = Belt_Array.reduce(ports, 0, (acc, p) => {
    if (p.state === "Open" && p.risk === "Critical") {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
  let ephemeralPortsActive = Belt_Array.reduce(ports, 0, (acc, p) => {
    let match = p.state;
    if (typeof match !== "object") {
      return acc;
    } else {
      return acc + 1 | 0;
    }
  });
  let securityDelta = -(((openPorts << 1) + (criticalPortsOpen * 10 | 0) | 0) + (ephemeralPortsActive << 0) | 0) | 0;
  return {
    openPorts: openPorts,
    criticalPortsOpen: criticalPortsOpen,
    ephemeralPortsActive: ephemeralPortsActive,
    securityDelta: securityDelta
  };
}

function syncSecurityToGaps(vulnerabilities) {
  let vulnerabilityCount = vulnerabilities.length;
  let criticalVulns = Belt_Array.reduce(vulnerabilities, 0, (acc, v) => {
    if (v.severity === "Critical") {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
  let gaps = Belt_Array.map(vulnerabilities, v => "gap-" + v.id);
  return {
    vulnerabilityCount: vulnerabilityCount,
    criticalVulns: criticalVulns,
    gaps: gaps
  };
}

function syncGapFixesToSecurity(gapsBeforeFix, gapsAfterFix) {
  let gapsFixed = gapsBeforeFix - gapsAfterFix | 0;
  let securityImprovement = gapsFixed * 5 | 0;
  let newComplianceScore = Primitive_int.min(100, 70 + (gapsFixed * 3 | 0) | 0);
  return {
    gapsFixed: gapsFixed,
    securityImprovement: securityImprovement,
    newComplianceScore: newComplianceScore
  };
}

function updateSecurityMetricsFromPorts(currentMetrics, portImpact) {
  return {
    security: Primitive_int.max(0, Primitive_int.min(100, currentMetrics.security + portImpact.securityDelta | 0)),
    performance: currentMetrics.performance,
    reliability: currentMetrics.reliability,
    compliance: currentMetrics.compliance
  };
}

function updateSecurityMetricsFromGaps(currentMetrics, gapSync) {
  return {
    security: Primitive_int.max(0, Primitive_int.min(100, currentMetrics.security + gapSync.securityImprovement | 0)),
    performance: currentMetrics.performance,
    reliability: currentMetrics.reliability,
    compliance: gapSync.newComplianceScore
  };
}

function generatePortWarnings(ports) {
  let warnings = [];
  let openCriticalPorts = Belt_Array.keep(ports, p => {
    if (p.state === "Open") {
      return p.risk === "Critical";
    } else {
      return false;
    }
  });
  if (openCriticalPorts.length !== 0) {
    Belt_Array.forEach(openCriticalPorts, port => {
      warnings.push(`CRITICAL: Port ` + String(port.number) + ` (` + port.protocol + `) is open permanently`);
    });
  }
  let openPorts = Belt_Array.keep(ports, p => p.state === "Open");
  if (openPorts.length > 5) {
    warnings.push(`HIGH: ` + String(openPorts.length) + ` ports open - consider reducing attack surface`);
  }
  Belt_Array.forEach(ports, port => {
    let duration = port.state;
    if (typeof duration !== "object") {
      return;
    }
    let duration$1 = duration._0;
    if (duration$1 < 60) {
      warnings.push(`INFO: Port ` + String(port.number) + ` ephemeral pinhole expires in ` + String(duration$1) + `s`);
      return;
    }
  });
  return warnings;
}

function calculateSystemHealth(securityMetrics, portImpact, gapCount) {
  let metricsScore = (((securityMetrics.security + securityMetrics.performance | 0) + securityMetrics.reliability | 0) + securityMetrics.compliance | 0) / 4 | 0;
  let portPenalty = (portImpact.criticalPortsOpen * 10 | 0) + (portImpact.openPorts << 1) | 0;
  let gapPenalty = gapCount * 3 | 0;
  return Primitive_int.max(0, Primitive_int.min(100, (metricsScore - portPenalty | 0) - gapPenalty | 0));
}

export {
  calculatePortSecurityImpact,
  syncSecurityToGaps,
  syncGapFixesToSecurity,
  updateSecurityMetricsFromPorts,
  updateSecurityMetricsFromGaps,
  generatePortWarnings,
  calculateSystemHealth,
}
/* No side effect */
