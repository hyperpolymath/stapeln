// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function parsePath(path) {
  return Belt_List.keep(Belt_List.fromArray(path.split("/")), segment => segment.length > 0);
}

function getCurrentPath() {
  return window.location.pathname;
}

function navigate(path) {
  ((window.history.pushState(null, "", path)));
  ((window.dispatchEvent(new PopStateEvent('popstate'))));
}

function replace(path) {
  ((window.history.replaceState(null, "", path)));
}

function onRouteChange(callback) {
  ((window.addEventListener('popstate', handler)));
}

function exact(expected, segments) {
  let expectedSegments = parsePath(expected);
  return Primitive_object.equal(expectedSegments, segments);
}

function prefix(expected, segments) {
  let expectedSegments = parsePath(expected);
  let _exp = expectedSegments;
  let _seg = segments;
  while (true) {
    let seg = _seg;
    let exp = _exp;
    if (exp === 0) {
      return true;
    }
    if (seg === 0) {
      return false;
    }
    if (!Primitive_object.equal(exp.hd, seg.hd)) {
      return false;
    }
    _seg = seg.tl;
    _exp = exp.tl;
    continue;
  };
}

function param(segments) {
  if (segments !== 0) {
    return [
      segments.hd,
      segments.tl
    ];
  }
}

let Match = {
  exact: exact,
  prefix: prefix,
  param: param
};

function make(path, value) {
  return segments => {
    if (exact(path, segments)) {
      return Primitive_option.some(value);
    }
  };
}

function makeWithParam(path, constructor) {
  return segments => {
    if (!prefix(path, segments)) {
      return;
    }
    let prefixLen = Belt_List.length(parsePath(path));
    let remaining = Belt_List.drop(segments, prefixLen);
    if (remaining === undefined) {
      return;
    }
    let match = param(remaining);
    if (match !== undefined) {
      return Primitive_option.some(constructor(match[0]));
    }
  };
}

function oneOf(routes) {
  return segments => {
    let _routes = Belt_List.fromArray(routes);
    while (true) {
      let routes$1 = _routes;
      if (routes$1 === 0) {
        return;
      }
      let value = routes$1.hd(segments);
      if (value !== undefined) {
        return Primitive_option.some(Primitive_option.valFromOption(value));
      }
      _routes = routes$1.tl;
      continue;
    };
  };
}

let Route = {
  make: make,
  makeWithParam: makeWithParam,
  oneOf: oneOf
};

function getRoute(config) {
  let path = getCurrentPath();
  let segments = parsePath(path);
  let route = config.routes(segments);
  if (route !== undefined) {
    return config.toMsg(Primitive_option.valFromOption(route));
  } else {
    return config.notFound;
  }
}

function subscriptions(config, dispatch) {
  onRouteChange(_path => dispatch(getRoute(config)));
}

let Router = {
  getRoute: getRoute,
  subscriptions: subscriptions
};

export {
  parsePath,
  getCurrentPath,
  navigate,
  replace,
  onRouteChange,
  Match,
  Route,
  Router,
}
/* No side effect */
