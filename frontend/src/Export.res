// SPDX-License-Identifier: PMPL-1.0-or-later
// Export.res - Export designs to files

open Model
open DesignFormat

// Get current ISO timestamp
let getCurrentTimestamp = (): string => {
  let date = Date.make()
  Date.toISOString(date)
}

// Download a string as a file
let downloadFile = (filename: string, content: string, mimeType: string) => {
  // Create blob
  let blob = WebAPI.makeBlob([content], {"type": mimeType})

  // Create download link
  let url = WebAPI.createObjectURL(blob)
  let link = WebAPI.createElement("a")

  link->WebAPI.setAttribute("href", url)
  link->WebAPI.setAttribute("download", filename)
  link
  ->WebAPI.elementToHtml
  ->Belt.Option.forEach(htmlElement => {
    // Trigger download
    htmlElement->WebAPI.click
  })

  // Cleanup
  WebAPI.revokeObjectURL(url)
}

// Export design to JSON file
let exportDesignToJson = (model: model, description: string) => {
  let metadata: designMetadata = {
    version: currentVersion,
    created: getCurrentTimestamp(),
    author: "Jonathan D.A. Jewell <jonathan.jewell@open.ac.uk>",
    description,
  }

  let jsonString = serializeDesign(model, metadata)
  let timestamp = Date.now()->Float.toString
  let filename = "stapeln-design-" ++ timestamp ++ ".json"

  downloadFile(filename, jsonString, "application/json")
  Console.log("Exported design to " ++ filename)
}

// Export to compose.toml format (selur-compose)
let exportToSelurCompose = (model: model) => {
  let toml = "# Generated by stapeln (selur-compose format)\n\n" ++ "[stack]\n" ++ "name = \"my-stack\"\n" ++ "version = \"1.0\"\n\n"

  // Add services
  let services =
    model.components
    ->Array.map(comp => {
      let image = componentTypeToImage(comp.componentType)
      let portLine = switch comp.config->Dict.get("port") {
      | Some(port) => "port = " ++ port ++ "\n"
      | None => ""
      }
      "[[services]]\n" ++
      "name = \"" ++
      comp.id ++
      "\"\n" ++
      "type = \"" ++
      componentTypeToString(comp.componentType) ++
      "\"\n" ++
      "image = \"" ++
      image ++
      "\"\n" ++
      portLine
    })
    ->Js.Array2.joinWith("\n")

  let fullToml = toml ++ services

  let timestamp = Date.now()->Float.toString
  let filename = "compose-" ++ timestamp ++ ".toml"

  downloadFile(filename, fullToml, "text/plain")
  Console.log("Exported to " ++ filename)
}

// Map component type to a container image
let componentTypeToImage = (ct: componentType): string => {
  switch ct {
  | CerroTorre => "cgr.dev/chainguard/wolfi-base:latest"
  | LagoGrey => "ghcr.io/hyperpolymath/lago-grey:latest"
  | Svalinn => "ghcr.io/hyperpolymath/svalinn:latest"
  | Selur => "ghcr.io/hyperpolymath/selur:latest"
  | Vordr => "ghcr.io/hyperpolymath/vordr:latest"
  | Podman => "cgr.dev/chainguard/wolfi-base:latest"
  | Docker => "cgr.dev/chainguard/wolfi-base:latest"
  | Nerdctl => "cgr.dev/chainguard/wolfi-base:latest"
  | Volume => "busybox:latest"
  | Network => "busybox:latest"
  }
}

// Export to docker-compose.yml format
let exportToDockerCompose = (model: model) => {
  let yaml = "# Generated by stapeln\n" ++ "version: '3.8'\n\n" ++ "services:\n"

  // Add services
  let services =
    model.components
    ->Array.map(comp => {
      let image = componentTypeToImage(comp.componentType)
      let portLine = switch comp.config->Dict.get("port") {
      | Some(port) => "    ports:\n      - \"" ++ port ++ ":" ++ port ++ "\"\n"
      | None => ""
      }
      "  " ++
      comp.id ++
      ":\n" ++
      "    image: " ++
      image ++
      "\n" ++
      "    # type: " ++
      componentTypeToString(comp.componentType) ++
      "\n" ++
      portLine
    })
    ->Js.Array2.joinWith("\n")

  let fullYaml = yaml ++ services

  let timestamp = Date.now()->Float.toString
  let filename = "docker-compose-" ++ timestamp ++ ".yml"

  downloadFile(filename, fullYaml, "text/yaml")
  Console.log("Exported to " ++ filename)
}

// Export to podman-compose.yml format (same as docker-compose)
let exportToPodmanCompose = (model: model) => {
  exportToDockerCompose(model)
}
