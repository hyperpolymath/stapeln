// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Model from "./Model.res.js";
import * as Toast from "./Toast.res.js";
import * as React from "react";
import * as Update from "./Update.res.js";
import * as Settings from "./Settings.res.js";
import * as AppRouter from "./AppRouter.res.js";
import * as StackView from "./StackView.res.js";
import * as StateSync from "./StateSync.res.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Breadcrumb from "./Breadcrumb.res.js";
import * as Navigation from "./Navigation.res.js";
import * as GapAnalysis from "./GapAnalysis.res.js";
import * as TopologyView from "./TopologyView.res.js";
import * as ErrorBoundary from "./ErrorBoundary.res.js";
import * as SimulationMode from "./SimulationMode.res.js";
import * as HealthIndicator from "./HealthIndicator.res.js";
import * as PortConfigPanel from "./PortConfigPanel.res.js";
import * as SecurityInspector from "./SecurityInspector.res.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as LagoGreyImageDesigner from "./LagoGreyImageDesigner.res.js";

function init() {
  return {
    currentRoute: AppRouter.getCurrentRoute(),
    model: Model.initialModel,
    portConfig: PortConfigPanel.init,
    securityInspector: SecurityInspector.init,
    gapAnalysis: GapAnalysis.init,
    simulationMode: SimulationMode.init,
    toastState: Toast.initialState,
    systemHealth: 85,
    isDark: true
  };
}

function update(msg, state) {
  if (typeof msg !== "object") {
    switch (msg) {
      case "SyncPortsToSecurity" :
        let impact = StateSync.calculatePortSecurityImpact(state.portConfig.ports);
        let newMetrics = StateSync.updateSecurityMetricsFromPorts(state.securityInspector.metrics, impact);
        let init = state.securityInspector;
        return {
          currentRoute: state.currentRoute,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: {
            metrics: newMetrics,
            grade: init.grade,
            vulnerabilities: init.vulnerabilities,
            checks: init.checks,
            exposedPorts: init.exposedPorts,
            selectedVulnerability: init.selectedVulnerability,
            showDetails: init.showDetails,
            filterSeverity: init.filterSeverity
          },
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: state.toastState,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
      case "SyncSecurityToGaps" :
      case "SyncGapsToSecurity" :
        return state;
      case "UpdateSystemHealth" :
        let portImpact = StateSync.calculatePortSecurityImpact(state.portConfig.ports);
        let gapCount = state.gapAnalysis.gaps.length;
        let systemHealth = StateSync.calculateSystemHealth(state.securityInspector.metrics, portImpact, gapCount);
        return {
          currentRoute: state.currentRoute,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: state.toastState,
          systemHealth: systemHealth,
          isDark: state.isDark
        };
    }
  } else {
    switch (msg.TAG) {
      case "RouteChanged" :
        return {
          currentRoute: msg._0,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: state.toastState,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
      case "NavigateTo" :
        let route = msg._0;
        AppRouter.navigateTo(route);
        return {
          currentRoute: route,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: state.toastState,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
      case "StackMsg" :
        let newModel = Update.update(state.model, msg._0);
        return {
          currentRoute: state.currentRoute,
          model: newModel,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: state.toastState,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
      case "PortConfigMsg" :
        let newPortConfig = PortConfigPanel.update(msg._0, state.portConfig);
        let impact$1 = StateSync.calculatePortSecurityImpact(newPortConfig.ports);
        let newSecurityMetrics = StateSync.updateSecurityMetricsFromPorts(state.securityInspector.metrics, impact$1);
        let warnings = StateSync.generatePortWarnings(newPortConfig.ports);
        let stateWithToasts;
        if (warnings.length !== 0) {
          let firstWarning = Belt_Array.get(warnings, 0);
          let toastMsg = firstWarning !== undefined ? (
              firstWarning.includes("CRITICAL") ? Toast.error(firstWarning) : (
                  firstWarning.includes("HIGH") ? Toast.warning(firstWarning) : Toast.info(firstWarning)
                )
            ) : Toast.info("Port configuration updated");
          let newToastState = Toast.update({
            TAG: "ShowToast",
            _0: toastMsg[0],
            _1: toastMsg[1],
            _2: toastMsg[2]
          }, state.toastState);
          stateWithToasts = {
            currentRoute: state.currentRoute,
            model: state.model,
            portConfig: state.portConfig,
            securityInspector: state.securityInspector,
            gapAnalysis: state.gapAnalysis,
            simulationMode: state.simulationMode,
            toastState: newToastState,
            systemHealth: state.systemHealth,
            isDark: state.isDark
          };
        } else {
          stateWithToasts = state;
        }
        let gapCount$1 = state.gapAnalysis.gaps.length;
        let systemHealth$1 = StateSync.calculateSystemHealth(newSecurityMetrics, impact$1, gapCount$1);
        let init$1 = state.securityInspector;
        return {
          currentRoute: stateWithToasts.currentRoute,
          model: stateWithToasts.model,
          portConfig: newPortConfig,
          securityInspector: {
            metrics: newSecurityMetrics,
            grade: init$1.grade,
            vulnerabilities: init$1.vulnerabilities,
            checks: init$1.checks,
            exposedPorts: init$1.exposedPorts,
            selectedVulnerability: init$1.selectedVulnerability,
            showDetails: init$1.showDetails,
            filterSeverity: init$1.filterSeverity
          },
          gapAnalysis: stateWithToasts.gapAnalysis,
          simulationMode: stateWithToasts.simulationMode,
          toastState: stateWithToasts.toastState,
          systemHealth: systemHealth$1,
          isDark: stateWithToasts.isDark
        };
      case "SecurityInspectorMsg" :
        let newSecurityInspector = SecurityInspector.update(msg._0, state.securityInspector);
        let gapSync = StateSync.syncSecurityToGaps(newSecurityInspector.vulnerabilities);
        let stateWithToast;
        if (gapSync.criticalVulns > 0) {
          let message = `Found ` + String(gapSync.criticalVulns) + ` critical vulnerabilities`;
          let newToastState$1 = Toast.update({
            TAG: "ShowToast",
            _0: message,
            _1: "Error",
            _2: 5000
          }, state.toastState);
          stateWithToast = {
            currentRoute: state.currentRoute,
            model: state.model,
            portConfig: state.portConfig,
            securityInspector: state.securityInspector,
            gapAnalysis: state.gapAnalysis,
            simulationMode: state.simulationMode,
            toastState: newToastState$1,
            systemHealth: state.systemHealth,
            isDark: state.isDark
          };
        } else {
          stateWithToast = state;
        }
        return {
          currentRoute: stateWithToast.currentRoute,
          model: stateWithToast.model,
          portConfig: stateWithToast.portConfig,
          securityInspector: newSecurityInspector,
          gapAnalysis: stateWithToast.gapAnalysis,
          simulationMode: stateWithToast.simulationMode,
          toastState: stateWithToast.toastState,
          systemHealth: stateWithToast.systemHealth,
          isDark: stateWithToast.isDark
        };
      case "GapAnalysisMsg" :
        let oldGapCount = state.gapAnalysis.gaps.length;
        let newGapAnalysis = GapAnalysis.update(msg._0, state.gapAnalysis);
        let newGapCount = newGapAnalysis.gaps.length;
        let stateWithUpdates;
        if (newGapCount < oldGapCount) {
          let gapSync$1 = StateSync.syncGapFixesToSecurity(oldGapCount, newGapCount);
          let newSecurityMetrics$1 = StateSync.updateSecurityMetricsFromGaps(state.securityInspector.metrics, gapSync$1);
          let message$1 = `Fixed ` + String(gapSync$1.gapsFixed) + ` security gaps`;
          let newToastState$2 = Toast.update({
            TAG: "ShowToast",
            _0: message$1,
            _1: "Success",
            _2: 4000
          }, state.toastState);
          let init$2 = state.securityInspector;
          stateWithUpdates = {
            currentRoute: state.currentRoute,
            model: state.model,
            portConfig: state.portConfig,
            securityInspector: {
              metrics: newSecurityMetrics$1,
              grade: init$2.grade,
              vulnerabilities: init$2.vulnerabilities,
              checks: init$2.checks,
              exposedPorts: init$2.exposedPorts,
              selectedVulnerability: init$2.selectedVulnerability,
              showDetails: init$2.showDetails,
              filterSeverity: init$2.filterSeverity
            },
            gapAnalysis: state.gapAnalysis,
            simulationMode: state.simulationMode,
            toastState: newToastState$2,
            systemHealth: state.systemHealth,
            isDark: state.isDark
          };
        } else {
          stateWithUpdates = state;
        }
        let portImpact$1 = StateSync.calculatePortSecurityImpact(state.portConfig.ports);
        let systemHealth$2 = StateSync.calculateSystemHealth(stateWithUpdates.securityInspector.metrics, portImpact$1, newGapCount);
        return {
          currentRoute: stateWithUpdates.currentRoute,
          model: stateWithUpdates.model,
          portConfig: stateWithUpdates.portConfig,
          securityInspector: stateWithUpdates.securityInspector,
          gapAnalysis: newGapAnalysis,
          simulationMode: stateWithUpdates.simulationMode,
          toastState: stateWithUpdates.toastState,
          systemHealth: systemHealth$2,
          isDark: stateWithUpdates.isDark
        };
      case "SimulationModeMsg" :
        let newSimulationMode = SimulationMode.update(msg._0, state.simulationMode);
        return {
          currentRoute: state.currentRoute,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: newSimulationMode,
          toastState: state.toastState,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
      case "ToastMsg" :
        let newToastState$3 = Toast.update(msg._0, state.toastState);
        return {
          currentRoute: state.currentRoute,
          model: state.model,
          portConfig: state.portConfig,
          securityInspector: state.securityInspector,
          gapAnalysis: state.gapAnalysis,
          simulationMode: state.simulationMode,
          toastState: newToastState$3,
          systemHealth: state.systemHealth,
          isDark: state.isDark
        };
    }
  }
}

function AppIntegrated(props) {
  let match = React.useState(() => init());
  let setState = match[1];
  let state = match[0];
  let dispatch = msg => {
    let newState = update(msg, state);
    setState(param => newState);
  };
  React.useEffect(() => {
    AppRouter.onRouteChange(route => dispatch({
      TAG: "RouteChanged",
      _0: route
    }));
  }, []);
  let match$1 = state.currentRoute;
  let tmp;
  switch (match$1) {
    case "NetworkView" :
      tmp = TopologyView.view(state.model, state.isDark, stackMsg => dispatch({
        TAG: "StackMsg",
        _0: stackMsg
      }));
      break;
    case "StackView" :
      tmp = StackView.view(state.model);
      break;
    case "LagoGreyView" :
      tmp = JsxRuntime.jsx(LagoGreyImageDesigner.make, {});
      break;
    case "PortConfigView" :
      tmp = JsxRuntime.jsx(PortConfigPanel.make, {
        initialState: state.portConfig,
        onStateChange: newState => dispatch({
          TAG: "PortConfigMsg",
          _0: {
            TAG: "SelectPort",
            _0: 0
          }
        })
      });
      break;
    case "SecurityView" :
      tmp = JsxRuntime.jsx(SecurityInspector.make, {
        initialState: state.securityInspector,
        onStateChange: newState => dispatch({
          TAG: "SecurityInspectorMsg",
          _0: {
            TAG: "UpdateMetrics",
            _0: newState.metrics
          }
        })
      });
      break;
    case "GapAnalysisView" :
      tmp = JsxRuntime.jsx(GapAnalysis.make, {
        initialState: state.gapAnalysis,
        onStateChange: newState => dispatch({
          TAG: "GapAnalysisMsg",
          _0: {
            TAG: "SelectGap",
            _0: "0"
          }
        })
      });
      break;
    case "SimulationView" :
      tmp = JsxRuntime.jsx(SimulationMode.make, {
        initialState: state.simulationMode,
        onStateChange: newState => dispatch({
          TAG: "SimulationModeMsg",
          _0: "ToggleStats"
        })
      });
      break;
    case "SettingsView" :
      tmp = Settings.view(Settings.defaultSettings, state.isDark);
      break;
    case "NotFound" :
      tmp = JsxRuntime.jsx("div", {
        children: JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx("div", {
              children: "404",
              style: {
                fontSize: "72px",
                marginBottom: "20px"
              }
            }),
            JsxRuntime.jsx("div", {
              children: "Page not found",
              style: {
                color: "#8892a6",
                fontSize: "24px"
              }
            })
          ],
          style: {
            textAlign: "center"
          }
        }),
        style: {
          display: "flex",
          height: "100%",
          alignItems: "center",
          justifyContent: "center"
        }
      });
      break;
  }
  return JsxRuntime.jsx(ErrorBoundary.make, {
    children: JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx(Navigation.make, {
          currentRoute: state.currentRoute,
          onNavigate: route => dispatch({
            TAG: "NavigateTo",
            _0: route
          })
        }),
        JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx(Breadcrumb.make, {
              currentRoute: state.currentRoute
            }),
            JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx(HealthIndicator.make, {
                health: state.systemHealth
              }),
              style: {
                background: "rgba(10, 14, 26, 0.95)",
                borderBottom: "1px solid #2a3142",
                padding: "16px 20px"
              }
            }),
            JsxRuntime.jsx("div", {
              children: tmp,
              style: {
                background: "#0a0e1a",
                overflowY: "auto",
                flex: "1"
              }
            })
          ],
          style: {
            display: "flex",
            overflow: "hidden",
            flex: "1",
            flexDirection: "column"
          }
        }),
        JsxRuntime.jsx(Toast.make, {
          toasts: state.toastState.toasts,
          dispatch: msg => dispatch({
            TAG: "ToastMsg",
            _0: msg
          })
        })
      ],
      style: {
        display: "flex",
        height: "100vh"
      }
    }),
    onError: errorMsg => {
      console.error("Application error:", errorMsg);
    }
  });
}

let make = AppIntegrated;

export {
  init,
  update,
  make,
}
/* Toast Not a pure module */
