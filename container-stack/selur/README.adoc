// SPDX-FileCopyrightText: 2026 Jonathan D.A. Jewell
// SPDX-License-Identifier: PMPL-1.0-or-later

= selur: Ephapax-linear WASM Sealant
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: rouge

image:https://img.shields.io/badge/License-PMPL--1.0-blue.svg[License: PMPL-1.0,link="https://github.com/hyperpolymath/palimpsest-license"]
image:https://img.shields.io/badge/WASM-Zig-orange.svg[WASM,link="https://ziglang.org"]
image:https://img.shields.io/badge/Ephapax-linear-green.svg[Ephapax,link="https://github.com/hyperpolymath/ephapax"]

*Zero-copy IPC bridge between Svalinn and Vörðr*

`selur` (Icelandic for "seal") is a *zero-overhead WASM bridge* that enables *memory-safe, formally verifiable IPC* between *Svalinn* (edge gateway) and *Vörðr* (container runtime). It replaces serialization (e.g., JSON/HTTP) with *shared WASM memory* and enforces *linear types* for correctness.

== Overview

Traditional container orchestration uses heavyweight serialization protocols (JSON over HTTP, gRPC) for inter-component communication. This introduces latency, memory overhead, and type unsafety.

selur eliminates these costs by:

* *Zero-copy memory sharing* via WASM linear memory
* *Compile-time safety* via Ephapax linear types
* *Formal verification* via Idris2 proofs
* *Minimal overhead* via Zig → WASM32 compilation

=== Architecture

[source]
----
┌─────────┐                  ┌────────┐                  ┌────────┐
│ Svalinn │ ──── selur ────▶ │ Vörðr  │ ──── selur ────▶ │ Svalinn│
│ (Edge)  │   WASM bridge    │(Runtime)│   WASM bridge    │ (Edge) │
└─────────┘                  └────────┘                  └────────┘
                    ▲                            ▲
                    │                            │
                    └──── Ephapax-linear ────────┘
                          (Type safety)
----

== Key Features

[cols="2,3,3", options="header"]
|===
|Feature |Implementation |Benefit

|*Zero-Copy IPC*
|Ephapax-linear → WASM (Zig)
|~30–50% faster than JSON/HTTP serialization

|*Linear Types*
|Ephapax-linear
|No memory leaks or use-after-free in IPC

|*Formal Verification*
|Idris2 proofs
|Compile-time guarantees of IPC correctness

|*WASM/SDP Integration*
|Zig → WASM32
|Aligns with public-facing WASM proxy architecture

|*Rootless Compatibility*
|Shared memory + seccomp
|Works with rootless containers

|*OCI Standards*
|`.ctp` bundle support
|Compatible with verified container specifications
|===

== Installation

=== Prerequisites

* link:https://ziglang.org/[Zig] (for WASM compilation)
* link:https://github.com/hyperpolymath/ephapax[Ephapax] (linear type system)
* link:https://wasmtime.dev/[Wasmtime] (WASM runtime)

=== Build

[source,bash]
----
# Clone this repo
git clone https://github.com/hyperpolymath/selur
cd selur

# Build the sealant (Ephapax → WASM)
just build
----

== Usage

=== 1. Build the Sealant

[source,bash]
----
# Compile Ephapax-linear to WASM
just build

# Output: selur.wasm (WASM module for zero-copy IPC)
----

=== 2. Load in Svalinn/Vörðr

[source,rust]
----
// In your Rust runtime
use wasmtime::*;

fn load_selur() -> Result<(), Box<dyn std::error::Error>> {
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    let module = Module::from_file(&engine, "selur.wasm")?;
    let instance = Instance::new(&mut store, &module, &[])?;
    Ok(())
}
----

=== 3. Run with Unified CLI

[source,bash]
----
# Start the sealant
ct-seal run --selur selur.wasm myapp.ctp
----

== Ephapax-Linear Code

=== Bridge Definition

[source,ephapax]
----
// selur/ephapax/bridge.eph
region r:
  // Consume a request from Svalinn
  let req = Svalinn.receive_request@r()

  // Delegate to Vörðr (zero-copy)
  let resp = Vordr.handle_request@r(req)

  // Return response to Svalinn
  Svalinn.send_response@r(resp)
----

=== Compile to WASM

[source,bash]
----
# Uses Zig for zero-overhead WASM
just build
----

== Formal Verification

Idris2 proofs ensure correctness properties:

[source,idris]
----
-- selur/idris/proofs.idr
module Selur.Proofs

||| Prove that no requests are lost in transit
noLostRequests : (req: Request) -> (resp: Response) -> Type
noLostRequests req resp = ResponseMatchesRequest req resp

||| Prove that memory is never leaked
noMemoryLeaks : (before: MemoryState) -> (after: MemoryState) -> Type
noMemoryLeaks before after = AllRegionsFreed before after
----

== Project Structure

[source]
----
selur/
├── ephapax/
│   ├── bridge.eph          # Linear type definitions
│   └── types.eph           # Core types
├── zig/
│   ├── build.must          # Mustfile for WASM compilation
│   └── runtime.zig         # WASM runtime glue
├── idris/
│   ├── proofs.idr          # Formal verification
│   └── theorems.idr        # Correctness theorems
├── src/
│   └── lib.rs              # Rust integration library
├── examples/
│   ├── echo/               # Simple echo server
│   └── nginx/              # Nginx proxy example
├── docs/
│   ├── ARCHITECTURE.adoc   # Design documentation
│   └── INTEGRATION.adoc    # Integration guide
├── justfile
├── Cargo.toml
└── README.adoc
----

== Why "selur"?

* *Icelandic for "seal"*: Bridges Svalinn (edge) and Vörðr (runtime) like a seal bridges land and sea
* *Minimalist*: Single-purpose, well-defined interface
* *Type-safe*: Linear types prevent resource leaks, like a seal's waterproof coat prevents water leaks

== Performance

Preliminary benchmarks (Svalinn ↔ Vörðr round-trip):

[cols="2,1,1,1", options="header"]
|===
|Method |Latency |Throughput |Memory

|JSON/HTTP
|2.3ms
|4,300 req/s
|8.2MB

|gRPC
|1.1ms
|9,000 req/s
|4.1MB

|*selur (WASM)*
|*0.7ms*
|*14,000 req/s*
|*1.2MB*
|===

== Integration

=== With Svalinn (Edge Gateway)

[source,rescript]
----
// Svalinn integration
module Selur = {
  @module("./selur.wasm") external sendRequest: request => promise<response> = "send_request"

  let handleEdgeRequest = async (req) => {
    let resp = await sendRequest(req)
    resp
  }
}
----

=== With Vörðr (Container Runtime)

[source,rust]
----
// Vörðr integration
use selur::Bridge;

fn main() -> Result<()> {
    let bridge = Bridge::new("selur.wasm")?;
    bridge.start()?;
    Ok(())
}
----

== Fallbacks

* *Direct Svalinn ↔ Vörðr*: Disable selur with `--direct` for debugging
* *JSON/HTTP fallback*: Automatic degradation if WASM unavailable
* *Compatibility mode*: Works with standard OCI runtimes (Podman, containerd)

== Roadmap

See link:ROADMAP.adoc[ROADMAP.adoc] for development phases.

== License

PMPL-1.0-or-later. See link:LICENSE[LICENSE].

== Contributing

See link:CONTRIBUTING.adoc[CONTRIBUTING.adoc].

Priority areas:

* Formal verification proofs (Idris2)
* Additional language bindings (ReScript, Gleam)
* Performance benchmarking
* Integration testing with Svalinn/Vörðr

== Related Projects

* link:https://github.com/hyperpolymath/svalinn[Svalinn] - ReScript-powered edge gateway
* link:https://github.com/hyperpolymath/ephapax[Ephapax] - Linear type system for WASM
* link:https://github.com/hyperpolymath/verified-container-spec[Verified Container Spec] - Supply-chain verified containers
* link:https://github.com/hyperpolymath/cerro-torre[Cerro Torre] - Container tooling ecosystem

---

*selur: The seal that keeps your containers waterproof.*
