= selur Integration Examples
:toc:
:toclevels: 2

== Overview

This directory contains reference implementations for integrating selur with Svalinn (edge gateway) and Vörðr (container orchestrator).

*Integration Status:*

|===
| Component | Language | Status | Path

| Svalinn bindings
| ReScript + Deno
| ✅ Complete
| link:svalinn/[svalinn/]

| Vörðr bindings
| Elixir NIF (Rust)
| ✅ Complete
| link:vordr/[vordr/]
|===

== Architecture

[source]
----
┌─────────────────────────────────────┐
│ Svalinn (Edge Gateway)              │
│  - ReScript application code        │
│  - Deno runtime                     │
│  - HTTP/REST API                    │
│  - Policy enforcement               │
└─────────────┬───────────────────────┘
              │
              │ selur zero-copy IPC
              │ (ReScript → Deno FFI → Rust → WASM)
              ↓
┌─────────────────────────────────────┐
│ selur.wasm (Zero-Copy Bridge)       │
│  - WASM linear memory               │
│  - Ephapax-linear types             │
│  - Zig runtime (527KB)              │
│  - Idris2 formal proofs             │
└─────────────┬───────────────────────┘
              │
              │ selur zero-copy IPC
              │ (WASM → Rust → Elixir NIF)
              ↓
┌─────────────────────────────────────┐
│ Vörðr (Container Orchestrator)     │
│  - Elixir application               │
│  - BEAM VM supervision              │
│  - Container lifecycle              │
│  - Reversibility journal            │
└─────────────────────────────────────┘
----

== Why Zero-Copy Matters

**Traditional JSON/HTTP** (4 buffer copies, 700-2000 μs):
----
Svalinn → JSON encode → HTTP → JSON decode → Vörðr
         └─ copy 1 ──┘  └ copy 2 ┘  └─ copy 3 ──┘
Response ← JSON encode ← HTTP ← JSON decode ← Vörðr
          └─ copy 4 ──┘
----

**selur WASM** (0 buffer copies, <100 μs):
----
Svalinn → WASM linear memory (shared) → Vörðr
         └────── 0 copies ─────────┘
----

**Result:** 7-20x faster, predictable latency, 1MB fixed memory.

== Quick Start

=== Svalinn Integration (ReScript + Deno)

[source,bash]
----
cd svalinn/

# Install and build
deno task build

# Run example
deno run --allow-ffi --allow-read src/example.res.js
----

See link:svalinn/README.adoc[Svalinn README] for full documentation.

=== Vörðr Integration (Elixir NIF)

[source,bash]
----
cd vordr/

# Install dependencies
mix deps.get

# Compile Rust NIF
mix compile

# Run example
mix run -e "Vordr.Selur.Example.run()"
----

See link:vordr/README.adoc[Vörðr README] for full documentation.

== Performance Benchmarks

|===
| Payload Size | selur (WASM) | JSON/HTTP | Speedup

| 100 B
| 8.5 μs
| 78 μs
| 9.2x

| 1 KB
| 12.4 μs
| 195 μs
| 15.7x

| 10 KB
| 46.1 μs
| 847 μs
| 18.4x
|===

**Throughput:**

* selur: 10,000+ requests/second
* JSON/HTTP: 500-1,400 requests/second

== Container Operations

Both integrations support the full container lifecycle:

|===
| Operation | Command Code | Description

| `create_container`
| 0x01
| Create container from OCI image

| `start_container`
| 0x02
| Start created container

| `stop_container`
| 0x03
| Stop running container

| `inspect_container`
| 0x04
| Get container info (JSON)

| `delete_container`
| 0x05
| Delete stopped container

| `list_containers`
| 0x06
| List all container IDs
|===

== Request/Response Protocol

All operations use binary protocol over WASM linear memory:

**Request Format:**
----
Bytes:  0        1                5              5+N
       +--------+----------------+--------------+
       | Cmd    | Payload Length | Payload      |
       | 1 byte | 4 bytes (LE)   | N bytes      |
       +--------+----------------+--------------+
----

**Response Format:**
----
Bytes:  0        1                M
       +--------+----------------+
       | Status | Response Data  |
       | 1 byte | M bytes        |
       +--------+----------------+
----

**Status Codes:**

* `0x00` - Success
* `0x01` - Invalid request
* `0x02` - Container not found
* `0x03` - Container already exists
* `0x04` - Network error
* `0x05` - Internal error

== Language-Specific Examples

=== ReScript (Svalinn)

[source,rescript]
----
open Selur

let () = init()

let bridge = newBridge("./selur.wasm")

switch bridge {
| Ok(b) => {
    switch createContainer(b, "nginx:latest") {
    | Ok(containerId) => {
        let _ = startContainer(b, containerId)
        Console.log(`Started: ${containerId}`)
      }
    | Error(e) => Console.error(ErrorCode.toString(e))
    }
    freeBridge(b)
  }
| Error(e) => Console.error(ErrorCode.toString(e))
}

cleanup()
----

=== Elixir (Vörðr)

[source,elixir]
----
alias Vordr.Selur.Bridge

{:ok, bridge} = Bridge.new("/path/to/selur.wasm")

{:ok, container_id} = Bridge.create_container(bridge, "nginx:latest")
:ok = Bridge.start_container(bridge, container_id)

{:ok, containers} = Bridge.list_containers(bridge)
IO.inspect(containers)

:ok = Bridge.free(bridge)
----

== Memory Safety Guarantees

selur provides **triple memory safety**:

1. **Compile-time** - Ephapax linear types prevent use-after-free
2. **Runtime** - Zig bounds checking validates all accesses
3. **Formal** - Idris2 proofs mathematically verify correctness

**Verified Properties:**

* `noLostRequests` - Every request gets exactly one response
* `noMemoryLeaks` - All allocated memory is freed
* `noBufferOverflow` - All memory accesses are bounded
* `linearUsage` - Resources consumed exactly once

Run `just verify` to check proofs yourself!

== Testing

=== Unit Tests

**Svalinn (ReScript):**
[source,bash]
----
cd svalinn/
deno task test
----

**Vörðr (Elixir):**
[source,bash]
----
cd vordr/
mix test
----

=== Integration Tests

Coming soon: End-to-end integration tests with real containers.

== Troubleshooting

=== Svalinn Issues

**Problem:** `Library not loaded` error

**Solution:** Ensure `libselur.so` is in current directory or provide path:
[source,rescript]
----
init(~libPath=Some("/absolute/path/to/libselur.so"), ())
----

**Problem:** FFI permission denied

**Solution:** Run with `--allow-ffi`:
[source,bash]
----
deno run --allow-ffi --allow-read script.res.js
----

=== Vörðr Issues

**Problem:** NIF not loaded

**Solution:** Recompile NIF:
[source,bash]
----
mix clean
mix deps.get
mix compile
----

**Problem:** Segmentation fault

**Solution:**

1. Compile in release mode: `mix compile --force`
2. Verify WASM is valid: `just build`
3. Update Rustler: `mix deps.update rustler`

== Next Steps

After integration testing (Option 1), the roadmap includes:

1. **Option 2:** v1.1 async/await support
2. **Option 3:** Python bindings (via ctypes or pyo3)
3. **Option 4:** Community content (blog posts, tutorials)
4. **Option 5:** Performance deep dive and optimizations
5. **Option 6:** Other hyperpolymath projects

**Future:** `selur-compose` tool for multi-container orchestration (separate repo)

== Documentation

* link:../README.adoc[selur Project README]
* link:../docs/API.adoc[selur API Reference]
* link:../docs/ARCHITECTURE.adoc[Architecture Documentation]
* link:../wiki/Integration-Guide.adoc[Integration Guide (Wiki)]
* link:svalinn/README.adoc[Svalinn Integration README]
* link:vordr/README.adoc[Vörðr Integration README]

== License

PMPL-1.0-or-later (Polymath Public Mark License)

See link:../LICENSE[LICENSE] for full terms.

== Maintainer

**Jonathan D.A. Jewell** <jonathan.jewell@open.ac.uk>

**Co-Authored-By:** Claude Sonnet 4.5 <noreply@anthropic.com>
