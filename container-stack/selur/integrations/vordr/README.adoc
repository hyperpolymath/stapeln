= Vörðr Integration - Elixir NIF Bindings for selur
:toc:
:toclevels: 3

== Overview

Elixir Native Implemented Function (NIF) bindings for integrating https://github.com/hyperpolymath/vordr[Vörðr] (container orchestrator) with selur's zero-copy WASM IPC bridge.

*Stack:*

* **Elixir** - Orchestration layer (supervision trees, state management)
* **Rust NIF** - Native bindings via Rustler
* **selur WASM** - Zero-copy IPC bridge
* **BEAM VM** - Erlang runtime

*Performance:* 7-20x faster than JSON/HTTP, native Elixir integration.

== Installation

=== Prerequisites

[source,bash]
----
# Install Erlang/OTP 26+
asdf install erlang 26.2.5

# Install Elixir 1.16+
asdf install elixir 1.16.3

# Install Rust (for NIF compilation)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build selur WASM module
cd ../..
just build  # Creates zig/zig-out/bin/selur.wasm
----

=== Build NIF

[source,bash]
----
cd integrations/vordr

# Install dependencies
mix deps.get

# Compile Rust NIF
mix compile

# Run tests
mix test
----

== Usage

=== Basic Example

[source,elixir]
----
alias Vordr.Selur.Bridge

# Create bridge
{:ok, bridge} = Bridge.new("/absolute/path/to/selur.wasm")

# Get memory size
{:ok, size} = Bridge.memory_size(bridge)
IO.puts("Memory: #{size} bytes")

# Create container
{:ok, container_id} = Bridge.create_container(bridge, "nginx:latest")
IO.puts("Created: #{container_id}")

# Start container
:ok = Bridge.start_container(bridge, container_id)

# List containers
{:ok, containers} = Bridge.list_containers(bridge)

# Stop container
:ok = Bridge.stop_container(bridge, container_id)

# Delete container
:ok = Bridge.delete_container(bridge, container_id)

# Cleanup
:ok = Bridge.free(bridge)
----

=== Running Example

[source,bash]
----
# Run interactive example
mix run -e "Vordr.Selur.Example.run()"

# Or in IEx
iex -S mix
iex> Vordr.Selur.Example.run()
----

== API Reference

=== Module: `Vordr.Selur.Bridge`

All functions return `{:ok, result}` or `{:error, reason}` tuples.

==== Bridge Management

[source,elixir]
----
@spec new(String.t()) :: {:ok, bridge()} | {:error, error()}
----

Create new bridge instance from WASM module path.

**Parameters:**

* `wasm_path` - Absolute path to selur.wasm

**Returns:**

* `{:ok, bridge}` - Opaque bridge reference
* `{:error, :internal_error}` - WASM load failed

**Example:**
[source,elixir]
----
{:ok, bridge} = Bridge.new("/var/lib/selur/selur.wasm")
----

[source,elixir]
----
@spec free(bridge()) :: :ok
----

Free bridge resources. Always call when done to prevent resource leaks.

[source,elixir]
----
@spec memory_size(bridge()) :: {:ok, non_neg_integer()} | {:error, error()}
----

Get current WASM linear memory size in bytes.

==== Container Operations

[source,elixir]
----
@spec create_container(bridge(), String.t()) :: {:ok, String.t()} | {:error, error()}
----

Create container from OCI image reference.

**Returns:**

* `{:ok, container_id}` - Unique container ID string
* `{:error, :container_already_exists}` - Image already loaded
* `{:error, :network_error}` - Failed to pull image

**Example:**
[source,elixir]
----
{:ok, id} = Bridge.create_container(bridge, "nginx:latest")
{:ok, id} = Bridge.create_container(bridge, "ghcr.io/org/app:v1.0")
----

[source,elixir]
----
@spec start_container(bridge(), String.t()) :: :ok | {:error, error()}
----

Start a created container.

**Returns:**

* `:ok` - Container started
* `{:error, :container_not_found}` - No such container

[source,elixir]
----
@spec stop_container(bridge(), String.t()) :: :ok | {:error, error()}
----

Stop a running container.

[source,elixir]
----
@spec inspect_container(bridge(), String.t()) :: {:ok, String.t()} | {:error, error()}
----

Inspect container details. Returns JSON string with container info.

**Example:**
[source,elixir]
----
{:ok, json} = Bridge.inspect_container(bridge, container_id)
info = Jason.decode!(json)
IO.puts("State: #{info["state"]}")
----

[source,elixir]
----
@spec delete_container(bridge(), String.t()) :: :ok | {:error, error()}
----

Delete a stopped container.

[source,elixir]
----
@spec list_containers(bridge()) :: {:ok, [String.t()]} | {:error, error()}
----

List all container IDs.

**Example:**
[source,elixir]
----
{:ok, ["c1a2b3", "d4e5f6"]} = Bridge.list_containers(bridge)
----

=== Error Types

[source,elixir]
----
@type error ::
  :invalid_request |
  :container_not_found |
  :container_already_exists |
  :network_error |
  :internal_error |
  :unknown_error
----

== Integration with Vörðr

=== GenServer Wrapper

[source,elixir]
----
defmodule Vordr.ContainerManager do
  use GenServer

  alias Vordr.Selur.Bridge

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    wasm_path = Keyword.fetch!(opts, :wasm_path)

    case Bridge.new(wasm_path) do
      {:ok, bridge} ->
        {:ok, %{bridge: bridge, containers: %{}}}

      {:error, reason} ->
        {:stop, {:bridge_failed, reason}}
    end
  end

  @impl true
  def terminate(_reason, state) do
    Bridge.free(state.bridge)
    :ok
  end

  # Client API

  def create(image) do
    GenServer.call(__MODULE__, {:create, image})
  end

  def start(container_id) do
    GenServer.call(__MODULE__, {:start, container_id})
  end

  def stop(container_id) do
    GenServer.call(__MODULE__, {:stop, container_id})
  end

  def list do
    GenServer.call(__MODULE__, :list)
  end

  # Server callbacks

  @impl true
  def handle_call({:create, image}, _from, state) do
    case Bridge.create_container(state.bridge, image) do
      {:ok, container_id} ->
        containers = Map.put(state.containers, container_id, %{image: image, state: :created})
        {:reply, {:ok, container_id}, %{state | containers: containers}}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call({:start, container_id}, _from, state) do
    case Bridge.start_container(state.bridge, container_id) do
      :ok ->
        containers = put_in(state.containers, [container_id, :state], :running)
        {:reply, :ok, %{state | containers: containers}}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call({:stop, container_id}, _from, state) do
    case Bridge.stop_container(state.bridge, container_id) do
      :ok ->
        containers = put_in(state.containers, [container_id, :state], :stopped)
        {:reply, :ok, %{state | containers: containers}}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call(:list, _from, state) do
    case Bridge.list_containers(state.bridge) do
      {:ok, ids} ->
        {:reply, {:ok, ids}, state}

      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end
end
----

=== Supervision Tree

[source,elixir]
----
defmodule Vordr.Application do
  use Application

  @impl true
  def start(_type, _args) do
    wasm_path = Application.get_env(:vordr, :selur_wasm_path)

    children = [
      {Vordr.ContainerManager, wasm_path: wasm_path}
    ]

    opts = [strategy: :one_for_one, name: Vordr.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
----

== Performance

=== Zero-Copy IPC Advantages

Traditional Elixir → Rust → WASM flow requires multiple copies:

----
Elixir binary → Rust Vec → WASM memory → Handler
              └─ copy ──┘  └─ copy ──┘
----

selur uses WASM linear memory (zero-copy):

----
Elixir binary → WASM memory (shared) → Handler
              └────── 0 copies ──────┘
----

=== Benchmarks (from Elixir)

|===
| Payload Size | selur (WASM) | JSON/HTTP | Speedup

| 100 B
| 8.5 μs
| 78 μs
| 9.2x

| 1 KB
| 12.4 μs
| 195 μs
| 15.7x

| 10 KB
| 46.1 μs
| 847 μs
| 18.4x
|===

**Throughput:**

* selur: 10,000+ requests/second
* JSON/HTTP: 500-1,400 requests/second

== Error Handling

Pattern match on result tuples:

[source,elixir]
----
case Bridge.create_container(bridge, "nginx:latest") do
  {:ok, container_id} ->
    IO.puts("Success: #{container_id}")

  {:error, :container_already_exists} ->
    IO.warn("Container already exists, skipping")

  {:error, :network_error} ->
    Logger.error("Network error - retrying...")
    # Implement retry logic

  {:error, reason} ->
    Logger.error("Unexpected error: #{reason}")
end
----

== Testing

[source,bash]
----
# Run tests
mix test

# Run with coverage
mix test --cover

# Run specific test file
mix test test/bridge_test.exs
----

== Troubleshooting

=== NIF Load Error

----
** (UndefinedFunctionError) function Vordr.Selur.Bridge.new/1 is undefined
----

**Fix:** Ensure NIF compiled successfully:

[source,bash]
----
mix clean
mix deps.get
mix compile
----

=== WASM Path Error

----
{:error, :internal_error}
----

**Fix:** Use absolute path to selur.wasm:

[source,elixir]
----
wasm_path = Path.expand("../../zig/zig-out/bin/selur.wasm", __DIR__)
{:ok, bridge} = Bridge.new(wasm_path)
----

=== Segmentation Fault

If NIF crashes with segfault:

1. Check Rust NIF is compiled in release mode: `mix compile --force`
2. Ensure WASM module is valid: `just build`
3. Verify Rustler version matches: `mix deps.update rustler`

== Architecture

[source]
----
┌─────────────────────────────────────┐
│ Vörðr (Elixir Application)         │
│  - GenServer container manager      │
│  - Supervision tree                 │
│  - State tracking                   │
│  - Reversibility journal            │
└─────────────┬───────────────────────┘
              │
              │ Elixir API calls
              ↓
┌─────────────────────────────────────┐
│ Vordr.Selur.Bridge (Elixir)         │
│  - Type specs                       │
│  - Pattern matching                 │
│  - Error handling                   │
└─────────────┬───────────────────────┘
              │
              │ NIF boundary
              ↓
┌─────────────────────────────────────┐
│ selur_nif (Rust NIF via Rustler)    │
│  - Resource management              │
│  - Binary marshalling               │
│  - Error conversion                 │
└─────────────┬───────────────────────┘
              │
              │ Rust Bridge API
              ↓
┌─────────────────────────────────────┐
│ selur::Bridge (Rust)                │
│  - WASM runtime (wasmtime)          │
│  - Memory management                │
│  - Request/response handling        │
└─────────────┬───────────────────────┘
              │
              │ WASM linear memory (zero-copy)
              ↓
┌─────────────────────────────────────┐
│ selur.wasm (Zig Runtime)            │
│  - IPC protocol                     │
│  - Bounds checking                  │
│  - Container operations             │
└─────────────────────────────────────┘
----

== License

PMPL-1.0-or-later (Polymath Public Mark License)

== See Also

* link:../../README.adoc[selur Project README]
* link:../../docs/API.adoc[selur API Reference]
* link:../../docs/ARCHITECTURE.adoc[Architecture Documentation]
* https://github.com/hyperpolymath/vordr[Vörðr Orchestrator]
* https://hexdocs.pm/rustler/[Rustler Documentation]
