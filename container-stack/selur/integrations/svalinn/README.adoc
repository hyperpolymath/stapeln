= Svalinn Integration - ReScript Bindings for selur
:toc:
:toclevels: 3

== Overview

Type-safe ReScript bindings for integrating https://github.com/hyperpolymath/svalinn[Svalinn] (edge gateway) with selur's zero-copy WASM IPC bridge.

*Stack:*

* **ReScript** - Application language (type-safe, compiles to JS)
* **Deno** - Runtime environment
* **Deno FFI** - Native library integration
* **selur WASM** - Zero-copy IPC bridge

*Performance:* 7-20x faster than JSON/HTTP via WASM linear memory.

== Installation

=== Prerequisites

[source,bash]
----
# Install Deno (v2.0+)
curl -fsSL https://deno.land/install.sh | sh

# Install ReScript compiler
deno install -g rescript

# Build selur WASM module
cd ../..
just build  # Creates zig/zig-out/bin/selur.wasm
----

=== Build Bindings

[source,bash]
----
cd integrations/svalinn
deno task build  # Compiles ReScript -> JS
----

== Usage

=== Basic Example

[source,rescript]
----
open Selur

// Initialize FFI library
let () = init()

// Create bridge
let bridge = newBridge("../../zig/zig-out/bin/selur.wasm")

switch bridge {
| Ok(b) => {
    // Create container
    switch createContainer(b, "nginx:latest") {
    | Ok(containerId) => {
        Console.log(`Created: ${containerId}`)

        // Start container
        let _ = startContainer(b, containerId)
      }
    | Error(e) => Console.error(ErrorCode.toString(e))
    }

    freeBridge(b)
  }
| Error(e) => Console.error(ErrorCode.toString(e))
}

cleanup()
----

=== Running Example

[source,bash]
----
# Build ReScript bindings
deno task build

# Run example (requires FFI and read permissions)
deno run --allow-ffi --allow-read src/example.res.js
----

== API Reference

=== Module: `Selur`

==== Initialization

[source,rescript]
----
let init: (~libPath: option<string>=?, unit) => unit
----

Initialize Deno FFI library. Call once at application startup.

*Parameters:*

* `libPath` - Optional path to `libselur.so` (defaults to `./libselur.so`)

[source,rescript]
----
let cleanup: unit => unit
----

Cleanup FFI resources. Call at application shutdown.

==== Bridge Management

[source,rescript]
----
type bridge

let newBridge: string => result<bridge, ErrorCode.t>
----

Create new bridge instance from WASM module path.

*Returns:* `Ok(bridge)` on success, `Error(errorCode)` on failure.

[source,rescript]
----
let freeBridge: bridge => unit
----

Free bridge resources. Always call when done.

[source,rescript]
----
let memorySize: bridge => int
----

Get current WASM linear memory size in bytes.

==== Container Operations

[source,rescript]
----
type containerRef = string
type imageRef = string

let createContainer: (bridge, imageRef) => result<containerRef, ErrorCode.t>
----

Create container from OCI image reference.

*Example:*
[source,rescript]
----
createContainer(bridge, "nginx:latest")
createContainer(bridge, "ghcr.io/org/app:v1.2.3")
----

[source,rescript]
----
let startContainer: (bridge, containerRef) => result<unit, ErrorCode.t>
----

Start a created container.

[source,rescript]
----
let stopContainer: (bridge, containerRef) => result<unit, ErrorCode.t>
----

Stop a running container.

[source,rescript]
----
let deleteContainer: (bridge, containerRef) => result<unit, ErrorCode.t>
----

Delete a stopped container.

[source,rescript]
----
let listContainers: bridge => result<array<containerRef>, ErrorCode.t>
----

List all container IDs.

=== Module: `Command`

[source,rescript]
----
type t =
  | CreateContainer
  | StartContainer
  | StopContainer
  | InspectContainer
  | DeleteContainer
  | ListContainers
----

Container operation commands.

=== Module: `ErrorCode`

[source,rescript]
----
type t =
  | Success
  | InvalidRequest
  | ContainerNotFound
  | ContainerAlreadyExists
  | NetworkError
  | InternalError
  | Unknown(int)

let fromU8: int => t
let toString: t => string
----

Error codes returned from selur operations.

== Integration with Svalinn

=== Gateway Handler

[source,rescript]
----
// src/gateway/ContainerHandler.res
open Selur

type state = {
  bridge: bridge,
}

let createState = (wasmPath: string): result<state, ErrorCode.t> => {
  init()

  switch newBridge(wasmPath) {
  | Ok(bridge) => Ok({bridge: bridge})
  | Error(e) => Error(e)
  }
}

let handleCreateRequest = (state: state, image: string): result<string, ErrorCode.t> => {
  createContainer(state.bridge, image)
}

let handleStartRequest = (state: state, containerId: string): result<unit, ErrorCode.t> => {
  startContainer(state.bridge, containerId)
}

let cleanupState = (state: state): unit => {
  freeBridge(state.bridge)
  cleanup()
}
----

=== Deno HTTP Server

[source,rescript]
----
// src/server/Main.res
@module("std/http/server.ts")
external serve: ({. "port": int, "handler": 'a => promise<'b>}) => unit = "serve"

let handleRequest = (state: ContainerHandler.state, req: 'a): promise<'b> => {
  // Parse request, call container operations, return response
  // Implementation specific to Svalinn's API
}

let main = () => {
  switch ContainerHandler.createState("./selur.wasm") {
  | Ok(state) => {
      Console.log("Starting Svalinn gateway on :8080")
      serve({
        "port": 8080,
        "handler": req => handleRequest(state, req),
      })
    }
  | Error(e) => {
      Console.error(`Failed to initialize: ${ErrorCode.toString(e)}`)
      Deno.exit(1)
    }
  }
}
----

== Performance

=== Zero-Copy IPC

Traditional JSON/HTTP requires 4 buffer copies:

----
App → JSON encode → HTTP send → JSON decode → Handler
     └─ copy 1 ──┘  └ copy 2 ┘  └─ copy 3 ──┘
Response ← JSON encode ← HTTP ← JSON decode ← Handler
         └─ copy 4 ──┘
----

selur WASM uses shared linear memory (0 copies):

----
App → WASM linear memory (shared) → Handler
     └────── 0 copies ─────────┘
----

=== Benchmarks

|===
| Payload Size | selur (WASM) | JSON/HTTP | Speedup

| 100 B
| 8.5 μs
| 78 μs
| 9.2x

| 1 KB
| 12.4 μs
| 195 μs
| 15.7x

| 10 KB
| 46.1 μs
| 847 μs
| 18.4x
|===

*Throughput:*

* selur: 10,000+ requests/second
* JSON/HTTP: 500-1,400 requests/second

== Error Handling

All operations return `result<'a, ErrorCode.t>`. Pattern match to handle errors:

[source,rescript]
----
switch createContainer(bridge, "nginx:latest") {
| Ok(containerId) => {
    Console.log(`Success: ${containerId}`)
    // Continue with container operations
  }
| Error(ErrorCode.ContainerAlreadyExists) => {
    Console.warn("Container already exists, skipping creation")
  }
| Error(ErrorCode.NetworkError) => {
    Console.error("Network error - retrying...")
    // Implement retry logic
  }
| Error(e) => {
    Console.error(`Unexpected error: ${ErrorCode.toString(e)}`)
  }
}
----

== Testing

[source,bash]
----
# Run tests
deno task test

# Run with coverage
deno test --allow-ffi --allow-read --coverage=coverage/
deno coverage coverage/
----

== Troubleshooting

=== "Library not loaded" Error

Ensure `libselur.so` (or `.dylib` on macOS, `.dll` on Windows) is in the current directory or provide explicit path:

[source,rescript]
----
init(~libPath=Some("/absolute/path/to/libselur.so"), ())
----

=== "Failed to create bridge" Error

* Verify WASM path is correct and absolute
* Check `selur.wasm` was built successfully (`just build`)
* Ensure file permissions allow reading

=== FFI Permission Denied

Run with `--allow-ffi` flag:

[source,bash]
----
deno run --allow-ffi --allow-read your-script.res.js
----

== Architecture

[source]
----
┌─────────────────────────────────────┐
│ Svalinn (ReScript Application)     │
│  - HTTP handlers                    │
│  - Business logic                   │
│  - Policy enforcement               │
└─────────────┬───────────────────────┘
              │
              │ Selur.res (type-safe bindings)
              ↓
┌─────────────────────────────────────┐
│ ffi.js (Deno FFI glue)              │
│  - dlopen("libselur.so")            │
│  - Symbol resolution                │
│  - Pointer marshalling              │
└─────────────┬───────────────────────┘
              │
              │ Native FFI calls
              ↓
┌─────────────────────────────────────┐
│ libselur.so (Rust Bridge)           │
│  - WASM runtime (wasmtime)          │
│  - Memory management                │
│  - Request/response handling        │
└─────────────┬───────────────────────┘
              │
              │ WASM linear memory (zero-copy)
              ↓
┌─────────────────────────────────────┐
│ selur.wasm (Zig Runtime)            │
│  - IPC protocol                     │
│  - Bounds checking                  │
│  - Container operations             │
└─────────────┬───────────────────────┘
              │
              │ IPC bridge
              ↓
┌─────────────────────────────────────┐
│ Vörðr (Container Orchestrator)     │
│  - Container lifecycle              │
│  - State management                 │
│  - Reversibility journal            │
└─────────────────────────────────────┘
----

== License

PMPL-1.0-or-later (Polymath Public Mark License)

== See Also

* link:../../README.adoc[selur Project README]
* link:../../docs/API.adoc[selur API Reference]
* link:../../docs/ARCHITECTURE.adoc[Architecture Documentation]
* https://github.com/hyperpolymath/svalinn[Svalinn Gateway]
* https://github.com/hyperpolymath/vordr[Vörðr Orchestrator]
