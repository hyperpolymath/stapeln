= selur Architecture
:toc:
:toclevels: 3

Architectural overview of the selur Ephapax-linear WASM sealant.

== Overview

selur provides zero-copy IPC between Svalinn (edge gateway) and Vörðr (container orchestrator) using:

1. **Ephapax-linear types** - Compile-time memory safety guarantees
2. **WASM linear memory** - Zero-copy shared memory between host and guest
3. **Idris2 formal proofs** - Mathematical correctness guarantees

== Components

=== 1. Ephapax Bridge (`ephapax/`)

**Language:** Ephapax-linear
**Purpose:** Type-safe IPC layer with linear types

[source]
----
ephapax/
├── bridge.eph   # Main bridge logic
└── types.eph    # Type definitions
----

**Key Features:**

* Linear types ensure resources are consumed exactly once
* Region annotations (`@r`) track memory ownership
* Compile-time guarantee of zero use-after-free
* Zero-copy semantics via WASM linear memory

**Example:**

[source,haskell]
----
bridge :: Region r => Request@r -> Response@r
bridge req =
  let validated_req = validate_request req in  -- Consumes req
  let response = vordr_handle validated_req in -- Consumes validated_req
  response                                     -- Transfers ownership
----

=== 2. Zig WASM Runtime (`zig/`)

**Language:** Zig
**Target:** WASM32-freestanding
**Purpose:** Low-level memory management and WASM exports

[source]
----
zig/
├── build.zig    # Build configuration
└── runtime.zig  # WASM runtime implementation
----

**Memory Layout:**

[source]
----
+-------------------+
| Linear Memory     |  1 MB buffer
| (1024 * 1024)     |
+-------------------+
| Request Buffer    |  Variable size
+-------------------+
| Response Buffer   |  Variable size
+-------------------+
----

**Exported Functions:**

* `allocate(size)` - Allocate memory
* `deallocate(ptr, size)` - Free memory
* `send_request(ptr, len)` - Process request
* `get_response(ptr)` - Get response length
* `get_memory_ptr()` - Get memory base pointer
* `get_memory_size()` - Get total memory size

=== 3. Idris2 Proofs (`idris/`)

**Language:** Idris2
**Purpose:** Formal correctness proofs

[source]
----
idris/
├── Proofs.idr    # Core proofs
└── Theorems.idr  # High-level theorems
----

**Proven Properties:**

1. **noLostRequests** - Every request gets exactly one response
2. **noMemoryLeaks** - All allocated memory is freed
3. **noBufferOverflow** - All memory accesses are bounded
4. **linearUsage** - Resources consumed exactly once
5. **responseMatchesRequest** - Correlation IDs match
6. **bridgeTerminates** - Guaranteed termination

**Theorems:**

1. **bridgeCorrectness** - Response matches request
2. **bridgeSafety** - No buffer overflows
3. **bridgeLiveness** - Always terminates
4. **bridgeUniqueness** - One request, one response

=== 4. Rust Bindings (`src/`)

**Language:** Rust
**Purpose:** Safe API for Svalinn/Vörðr integration

[source]
----
src/
└── lib.rs  # Bridge struct and API
----

**API:**

[source,rust]
----
pub struct Bridge { /* ... */ }

impl Bridge {
    pub fn new(wasm_path: impl AsRef<Path>) -> Result<Self>;
    pub fn send_request(&mut self, request: &[u8]) -> Result<Vec<u8>>;
    pub fn memory_size(&mut self) -> Result<usize>;
}
----

== Data Flow

=== Request Path

[source]
----
Svalinn (Deno/TypeScript)
  |
  | 1. Create request payload
  v
Rust Bridge (Wasmtime)
  |
  | 2. Load selur.wasm
  | 3. Allocate WASM memory
  | 4. Write request to linear memory
  v
WASM Runtime (Zig)
  |
  | 5. Bounds checking
  | 6. Parse request
  v
Ephapax Bridge
  |
  | 7. Linear type checking
  | 8. Validate request
  | 9. Dispatch to handler
  v
Vörðr (Elixir/Rust)
  |
  | 10. Execute container operation
  v
Ephapax Bridge
  |
  | 11. Construct response
  | 12. Transfer ownership
  v
WASM Runtime (Zig)
  |
  | 13. Write response to memory
  v
Rust Bridge (Wasmtime)
  |
  | 14. Read response from memory
  | 15. Deallocate request memory
  v
Svalinn
----

=== Response Path

Same as request path but in reverse, with response payload.

== Memory Safety

=== Linear Type Guarantees (Compile-Time)

Ephapax-linear ensures:

[source,haskell]
----
-- ✓ Legal: Resource consumed exactly once
f :: Request@r -> Response@r
f req = handle req  -- req consumed here

-- ✗ Illegal: Use-after-free
g :: Request@r -> (Response@r, Response@r)
g req = (handle req, handle req)  -- ERROR: req used twice

-- ✗ Illegal: Memory leak
h :: Request@r -> ()
h req = ()  -- ERROR: req not consumed
----

=== Runtime Guarantees (Checked at Runtime)

Zig WASM runtime checks:

* Request size ≤ MAX_REQUEST_SIZE (1 MB)
* Memory offset + length ≤ buffer capacity
* Pointer validity before dereferencing

[source,zig]
----
if (request_len > MAX_REQUEST_SIZE) {
    return @intFromEnum(ErrorCode.InvalidRequest);
}

if (request_ptr + request_len > memory.len) {
    return @intFromEnum(ErrorCode.InvalidRequest);
}
----

=== Formal Proofs (Mathematically Proven)

Idris2 proves properties using dependent types:

[source,idris]
----
-- Prove all memory is freed
noMemoryLeaks : (before : MemoryState) -> (after : MemoryState) -> Type
noMemoryLeaks (MkMemoryState alloc_before cap_before)
              (MkMemoryState alloc_after cap_after) =
  (alloc_after = 0, cap_before = cap_after)
----

== Performance

=== Zero-Copy Optimization

Traditional JSON/HTTP:

[source]
----
Request → JSON encode → HTTP → JSON decode → Process
         \___________ 2 copies __________/

Response ← JSON encode ← HTTP ← JSON decode ← Process
          \___________ 2 copies __________/

Total: 4 copies
----

selur WASM:

[source]
----
Request → WASM linear memory (shared) → Process
          \__________ 0 copies ________/

Response ← WASM linear memory (shared) ← Process
           \__________ 0 copies ________/

Total: 0 copies
----

=== Benchmark Targets

| Operation | Target Latency |
|-----------|----------------|
| Request allocation | < 1 μs |
| Memory write | < 10 μs |
| Bridge validation | < 50 μs |
| Total round-trip | < 100 μs |

Compare to JSON/HTTP:

| Operation | Typical Latency |
|-----------|-----------------|
| JSON encoding | 100-500 μs |
| HTTP overhead | 500-1000 μs |
| JSON decoding | 100-500 μs |
| Total round-trip | 700-2000 μs |

**Expected speedup**: 7-20x faster

== Security

=== Threat Model

**Trusted:**
* Svalinn gateway
* Vörðr orchestrator
* selur.wasm module

**Untrusted:**
* Container images
* Network inputs
* User-provided configurations

=== Mitigations

1. **Memory Safety** - Linear types prevent use-after-free
2. **Bounds Checking** - Runtime validation of all accesses
3. **Size Limits** - Maximum request size enforced
4. **Formal Verification** - Idris2 proofs guarantee correctness
5. **WASM Sandbox** - Isolation from host system

== Build Pipeline

[source]
----
Ephapax (.eph files)
  |
  | [Ephapax Compiler]  (BLOCKED - not yet available)
  v
Zig (.zig files)
  |
  | [Zig Compiler]
  v
WASM Module (.wasm)
  |
  | [Wasmtime Runtime]
  v
Rust Application
----

**Current Status:**

* Zig → WASM: ✅ Working (zig build wasm)
* Idris2 proofs: ✅ Verified (just verify)
* Rust bindings: ✅ Functional (cargo check)
* Ephapax → Zig: ⏳ Blocked on ephapax compiler

== Integration Points

=== Svalinn (Edge Gateway)

**Language:** TypeScript/Deno
**Communication:** Wasmtime-Deno bindings

[source,typescript]
----
import { Bridge } from "./selur.ts";

const bridge = new Bridge("selur.wasm");
const response = await bridge.sendRequest(request);
----

=== Vörðr (Container Orchestrator)

**Language:** Elixir + Rust
**Communication:** FFI via WASM exports

[source,elixir]
----
defmodule Vordr.Bridge do
  use Rustler, otp_app: :vordr, crate: "selur"

  def handle_request(_request), do: :erlang.nif_error(:nif_not_loaded)
end
----

== Future Work

=== v0.3-wasm
* Complete Ephapax → Zig codegen
* Integration tests with Svalinn/Vörðr
* Performance benchmarks

=== v0.4-proofs
* Complete all proof holes
* Property-based testing
* Fuzzing

=== v1.0-mvp
* Production deployment
* Security audit
* Documentation finalization

== License

PMPL-1.0-or-later
