-------------------------------------------------------------------------------
--  Cerro_SELinux - Implementation
-------------------------------------------------------------------------------

with Ada.Strings.Fixed; use Ada.Strings.Fixed;
with Ada.Characters.Handling;
with Ada.Directories;
with Ada.Text_IO;
with GNAT.OS_Lib;

package body Cerro_SELinux is

   function Generate_Confined_Policy
      (Package_Name : String;
       Executable   : String;
       Format       : Policy_Format := CIL) return Policy_Result
   is
      Result : Policy_Result;
      LF     : constant Character := Character'Val (10);
      Policy : Unbounded_String;

      --  Sanitize package name for SELinux type names (alphanumeric + underscore only)
      function Sanitize_Name (Name : String) return String is
         Sanitized : String := Name;
      begin
         for I in Sanitized'Range loop
            if not (Sanitized (I) in 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '-') then
               Sanitized (I) := '_';
            end if;
         end loop;
         return Sanitized;
      end Sanitize_Name;

      Type_Name : constant String := "cerro_" & Sanitize_Name (Package_Name) & "_t";
      Exec_Type : constant String := "cerro_" & Sanitize_Name (Package_Name) & "_exec_t";

   begin
      case Format is
         when CIL =>
            --  Generate CIL (Common Intermediate Language) policy
            Append (Policy, ";; SELinux CIL Policy for Cerro Torre Package" & LF);
            Append (Policy, ";; Package: " & Package_Name & LF);
            Append (Policy, ";; Generated by: Cerro Torre" & LF);
            Append (Policy, LF);

            --  Define the domain type
            Append (Policy, "(type " & Type_Name & ")" & LF);
            Append (Policy, "(typeattribute " & Type_Name & " domain)" & LF);
            Append (Policy, LF);

            --  Define the executable type
            Append (Policy, "(type " & Exec_Type & ")" & LF);
            Append (Policy, "(typeattribute " & Exec_Type & " file_type)" & LF);
            Append (Policy, "(typeattribute " & Exec_Type & " exec_type)" & LF);
            Append (Policy, LF);

            --  Allow domain transition
            Append (Policy, ";; Domain transition rules" & LF);
            Append (Policy, "(typetransition init_t " & Exec_Type & " process " & Type_Name & ")" & LF);
            Append (Policy, "(allow init_t " & Exec_Type & " (file (read open execute getattr)))" & LF);
            Append (Policy, "(allow init_t " & Type_Name & " (process (transition)))" & LF);
            Append (Policy, "(allow " & Type_Name & " " & Exec_Type & " (file (entrypoint)))" & LF);
            Append (Policy, LF);

            --  Basic permissions
            Append (Policy, ";; Basic file permissions" & LF);
            Append (Policy, "(allow " & Type_Name & " " & Exec_Type & " (file (read getattr execute open)))" & LF);
            Append (Policy, "(allow " & Type_Name & " bin_t (file (read getattr execute open)))" & LF);
            Append (Policy, "(allow " & Type_Name & " lib_t (file (read getattr open)))" & LF);
            Append (Policy, LF);

            --  File labeling
            Append (Policy, ";; File context labeling" & LF);
            Append (Policy, "(filecon """ & Executable & """ file " & Exec_Type & ")" & LF);

            Result.Success := True;
            Result.Policy_Text := Policy;

         when TE =>
            --  Generate Type Enforcement (.te) format
            Append (Policy, "## SELinux Policy Module for " & Package_Name & LF);
            Append (Policy, "## Generated by Cerro Torre" & LF);
            Append (Policy, LF);
            Append (Policy, "policy_module(" & Sanitize_Name (Package_Name) & ", 1.0.0)" & LF);
            Append (Policy, LF);
            Append (Policy, "type " & Type_Name & ";" & LF);
            Append (Policy, "type " & Exec_Type & ";" & LF);
            Append (Policy, "domain_type(" & Type_Name & ")" & LF);
            Append (Policy, "files_type(" & Exec_Type & ")" & LF);
            Append (Policy, LF);
            Append (Policy, "# Allow domain transition" & LF);
            Append (Policy, "domain_auto_trans(init_t, " & Exec_Type & ", " & Type_Name & ")" & LF);

            Result.Success := True;
            Result.Policy_Text := Policy;

         when PP =>
            --  Binary policy packages must be compiled from CIL or TE
            Result.Success := False;
            Result.Errors := To_Unbounded_String (
               "PP format requires compilation. Generate CIL or TE first, then compile with semodule_package.");
      end case;

      return Result;

   exception
      when others =>
         Result.Success := False;
         Result.Errors := To_Unbounded_String ("Error generating policy");
         return Result;
   end Generate_Confined_Policy;

   function Generate_Network_Policy
      (Package_Name : String;
       Ports        : String;
       Protocol     : String := "tcp") return Policy_Result
   is
      Result : Policy_Result;
      LF     : constant Character := Character'Val (10);
      Policy : Unbounded_String;

      function Sanitize_Name (Name : String) return String is
         Sanitized : String := Name;
      begin
         for I in Sanitized'Range loop
            if not (Sanitized (I) in 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '-') then
               Sanitized (I) := '_';
            end if;
         end loop;
         return Sanitized;
      end Sanitize_Name;

      Type_Name : constant String := "cerro_" & Sanitize_Name (Package_Name) & "_t";
      Port_Type : constant String := "cerro_" & Sanitize_Name (Package_Name) & "_port_t";

   begin
      --  Generate CIL network policy
      Append (Policy, ";; Network Policy for " & Package_Name & LF);
      Append (Policy, ";; Protocol: " & Protocol & LF);
      Append (Policy, ";; Ports: " & Ports & LF);
      Append (Policy, LF);

      --  Define port type
      Append (Policy, "(type " & Port_Type & ")" & LF);
      Append (Policy, "(typeattribute " & Port_Type & " port_type)" & LF);
      Append (Policy, LF);

      --  Allow network operations
      Append (Policy, ";; Network permissions" & LF);

      if Protocol = "tcp" then
         Append (Policy, "(allow " & Type_Name & " self (tcp_socket (");
         Append (Policy, "create connect listen accept read write bind getopt setopt)))" & LF);
         Append (Policy, "(allow " & Type_Name & " " & Port_Type & " (tcp_socket (name_bind name_connect)))" & LF);
      elsif Protocol = "udp" then
         Append (Policy, "(allow " & Type_Name & " self (udp_socket (");
         Append (Policy, "create connect read write bind getopt setopt)))" & LF);
         Append (Policy, "(allow " & Type_Name & " " & Port_Type & " (udp_socket (name_bind)))" & LF);
      end if;

      Append (Policy, LF);

      --  Port labeling (parse comma-separated port list)
      Append (Policy, ";; Port labeling" & LF);
      declare
         Port_List : constant String := Ports;
         Start_Pos : Positive := Port_List'First;
         Comma_Pos : Natural;
      begin
         loop
            Comma_Pos := Index (Port_List (Start_Pos .. Port_List'Last), ",");

            if Comma_Pos = 0 then
               --  Last port in list
               declare
                  Port : constant String := Trim (Port_List (Start_Pos .. Port_List'Last), Ada.Strings.Both);
               begin
                  if Port'Length > 0 then
                     Append (Policy, "(portcon " & Protocol & " " & Port & " " & Port_Type & ")" & LF);
                  end if;
               end;
               exit;
            else
               --  Extract port and continue
               declare
                  Port : constant String := Trim (Port_List (Start_Pos .. Comma_Pos - 1), Ada.Strings.Both);
               begin
                  if Port'Length > 0 then
                     Append (Policy, "(portcon " & Protocol & " " & Port & " " & Port_Type & ")" & LF);
                  end if;
               end;
               Start_Pos := Comma_Pos + 1;
            end if;
         end loop;
      end;

      Result.Success := True;
      Result.Policy_Text := Policy;
      return Result;

   exception
      when others =>
         Result.Success := False;
         Result.Errors := To_Unbounded_String ("Error generating network policy");
         return Result;
   end Generate_Network_Policy;

   function Validate_Policy
      (Policy : String;
       Format : Policy_Format := CIL) return Validation_Status
   is
      use Ada.Directories;
      use Ada.Text_IO;
      use GNAT.OS_Lib;

      Temp_File : constant String := "/tmp/cerro-policy-" & Natural'Image (Natural'First) & ".cil";
      F : File_Type;
      Success : Boolean;
      Exit_Status : Integer;
      Validator : String_Access;
   begin
      --  Only CIL format can be validated with secilc
      if Format /= CIL then
         return Unsupported_Format;
      end if;

      --  Write policy to temp file
      begin
         Create (F, Out_File, Temp_File);
         Put (F, Policy);
         Close (F);
      exception
         when others =>
            if Is_Open (F) then
               Close (F);
            end if;
            if Exists (Temp_File) then
               Delete_File (Temp_File);
            end if;
            return Validation_Failed;
      end;

      --  Run secilc to validate syntax
      Validator := Locate_Exec_On_Path ("secilc");
      if Validator = null then
         --  secilc not found - cannot validate
         if Exists (Temp_File) then
            Delete_File (Temp_File);
         end if;
         return Unsupported_Format;
      end if;

      declare
         Args : Argument_List :=
            (new String'(Temp_File),
             new String'("-o"),
             new String'("/dev/null"),
             new String'("-f"),
             new String'("/dev/null"));
      begin
         Exit_Status := Spawn (Validator.all, Args);

         --  Free arguments
         for Arg of Args loop
            Free (Arg);
         end loop;

         Free (Validator);

         --  Clean up temp file
         if Exists (Temp_File) then
            Delete_File (Temp_File);
         end if;

         if Exit_Status = 0 then
            return Valid;
         else
            return Syntax_Error;
         end if;
      end;

   exception
      when others =>
         if Exists (Temp_File) then
            Delete_File (Temp_File);
         end if;
         return Validation_Failed;
   end Validate_Policy;

   function Check_Permissions (Policy : String) return Boolean is
      Policy_Lower : constant String := Ada.Characters.Handling.To_Lower (Policy);

      function Contains (Substr : String) return Boolean is
      begin
         return Index (Policy_Lower, Substr) > 0;
      end Contains;

   begin
      --  Check for dangerous permissions that should not be granted

      --  1. Unconfined access (essentially disables SELinux for the process)
      if Contains ("unconfined_t") then
         return False;
      end if;

      --  2. Raw network sockets (can be used for packet sniffing)
      if Contains ("rawip_socket") and then not Contains ("# justified: rawip") then
         return False;
      end if;

      --  3. Write access to system directories
      if Contains ("allow") and then Contains ("etc_t") and then Contains ("(write") then
         return False;
      end if;

      if Contains ("allow") and then Contains ("sbin_t") and then Contains ("(write") then
         return False;
      end if;

      --  4. Kernel module loading
      if Contains ("kernel_module_type") or else Contains ("insmod") then
         return False;
      end if;

      --  5. System administration capabilities
      if Contains ("sys_admin") or else Contains ("sys_module") then
         return False;
      end if;

      --  6. Unrestricted file access
      if Contains ("files_unconfined_type") then
         return False;
      end if;

      --  Policy passes basic safety checks
      return True;

   end Check_Permissions;

   function Install_Policy (Policy_Path : String) return Boolean is
      use Ada.Directories;
      use GNAT.OS_Lib;

      Semodule : String_Access;
      Exit_Status : Integer;
   begin
      --  Verify policy file exists
      if not Exists (Policy_Path) then
         return False;
      end if;

      --  Locate semodule command
      Semodule := Locate_Exec_On_Path ("semodule");
      if Semodule = null then
         return False;
      end if;

      --  Execute semodule -i to install policy
      declare
         Args : Argument_List :=
            (new String'("-i"),
             new String'(Policy_Path));
      begin
         Exit_Status := Spawn (Semodule.all, Args);

         --  Free arguments
         for Arg of Args loop
            Free (Arg);
         end loop;

         Free (Semodule);

         return Exit_Status = 0;
      end;

   exception
      when others =>
         return False;
   end Install_Policy;

   function Remove_Policy (Module_Name : String) return Boolean is
      use GNAT.OS_Lib;

      Semodule : String_Access;
      Exit_Status : Integer;
   begin
      --  Verify module name is not empty
      if Module_Name'Length = 0 then
         return False;
      end if;

      --  Locate semodule command
      Semodule := Locate_Exec_On_Path ("semodule");
      if Semodule = null then
         return False;
      end if;

      --  Execute semodule -r to remove policy module
      declare
         Args : Argument_List :=
            (new String'("-r"),
             new String'(Module_Name));
      begin
         Exit_Status := Spawn (Semodule.all, Args);

         --  Free arguments
         for Arg of Args loop
            Free (Arg);
         end loop;

         Free (Semodule);

         return Exit_Status = 0;
      end;

   exception
      when others =>
         return False;
   end Remove_Policy;

end Cerro_SELinux;
