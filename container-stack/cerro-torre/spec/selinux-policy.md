# Cerro Torre SELinux Policy Generation

**Version**: 0.1.0-draft  
**Status**: Draft Specification  
**SPDX-License-Identifier**: PMPL-1.0-or-later

## Overview

Cerro Torre automatically generates minimal, verifiable SELinux policies for container images. Rather than relying on broad, general-purpose policies, each container receives a policy tailored to exactly what it contains and declares it needs.

## Design Principles

1. **Least Privilege by Construction**: Policies permit only what is declared, nothing more
2. **Declarative Input**: Policy requirements declared in manifest, not discovered at runtime
3. **Formally Verifiable**: Policy properties can be proven before deployment
4. **No Runtime Surprises**: If it's not in the policy, it's denied — no silent failures
5. **Auditable**: Clear mapping from manifest declarations to policy rules

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                  POLICY GENERATION PIPELINE                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐                                               │
│  │   MANIFEST   │  [selinux] section declarations               │
│  │   (.ctp)     │  - domain, capabilities, network, filesystem  │
│  └──────┬───────┘                                               │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────┐                                               │
│  │   POLICY     │  SPARK-verified policy compiler               │
│  │  GENERATOR   │  - Validates declarations                     │
│  │   (SPARK)    │  - Generates minimal policy                   │
│  └──────┬───────┘                                               │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────┐                                               │
│  │   POLICY     │  Formal verification of properties            │
│  │  VERIFIER    │  - No unintended permissions                  │
│  │   (SPARK)    │  - Completeness check                         │
│  └──────┬───────┘                                               │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────┐                                               │
│  │  COMPILED    │  Binary SELinux policy module                 │
│  │   POLICY     │  Ready for container deployment               │
│  │   (.cil)     │                                               │
│  └──────────────┘                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Manifest Declaration

The `[selinux]` section in `.ctp` manifests declares security requirements:

```ctp
[selinux]
# Domain type for this container
domain = "nginx_t"

# Linux capabilities required
capabilities = ["net_bind_service", "setuid", "setgid", "chown"]

# Network access
[selinux.network]
listen_tcp = [80, 443]
listen_udp = []
connect_tcp = ["upstream_t:8080", "any:443"]
connect_udp = []
raw_sockets = false

# Filesystem access
[selinux.filesystem]
read = [
    "/etc/nginx/",
    "/usr/share/nginx/",
    "/var/www/",
]
write = [
    "/var/log/nginx/",
    "/var/cache/nginx/",
    "/run/nginx.pid",
]
execute = [
    "/usr/sbin/nginx",
    "/usr/lib/nginx/modules/",
]
# Directories that can have files created
create_in = [
    "/var/log/nginx/",
    "/var/cache/nginx/",
]

# Process behaviour
[selinux.process]
can_fork = true
can_exec_self = false
can_exec_other = false  # No shell escapes
can_ptrace = false
transition_to = []  # No domain transitions

# IPC
[selinux.ipc]
shared_memory = false
message_queues = false
semaphores = false
unix_sockets = ["/run/nginx.sock"]

# Additional constraints
[selinux.constraints]
no_new_privileges = true
memory_execute = false  # W^X enforcement
```

## Policy Language

Generated policies use CIL (Common Intermediate Language), SELinux's modern policy language.

### Example Generated Policy

For the nginx manifest above:

```cil
; Auto-generated by Cerro Torre Policy Generator
; Source: manifests/nginx.ctp
; Generated: 2024-12-07T10:30:00Z

(block nginx
  ; Type definitions
  (type nginx_t)
  (type nginx_exec_t)
  (type nginx_conf_t)
  (type nginx_log_t)
  (type nginx_cache_t)
  (type nginx_content_t)
  
  ; Role association
  (roletype system_r nginx_t)
  
  ; Domain entry point
  (typeattributeset domain (nginx_t))
  (typeattributeset entry_type (nginx_exec_t))
  (typetransition unconfined_t nginx_exec_t process nginx_t)
  
  ; Capabilities
  (allow nginx_t self (capability (net_bind_service setuid setgid chown)))
  
  ; Network: listen on 80, 443
  (allow nginx_t self (tcp_socket (create listen accept bind)))
  (allow nginx_t node_t (tcp_socket (node_bind)))
  (portcon tcp 80 (system_u object_r nginx_port_t ((s0) (s0))))
  (portcon tcp 443 (system_u object_r nginx_port_t ((s0) (s0))))
  (allow nginx_t nginx_port_t (tcp_socket (name_bind)))
  
  ; Network: connect to upstreams
  (allow nginx_t upstream_t (tcp_socket (name_connect)))
  (allow nginx_t port_t (tcp_socket (name_connect)))  ; any:443
  
  ; Filesystem: read config
  (allow nginx_t nginx_conf_t (dir (search open read getattr)))
  (allow nginx_t nginx_conf_t (file (open read getattr)))
  
  ; Filesystem: read content
  (allow nginx_t nginx_content_t (dir (search open read getattr)))
  (allow nginx_t nginx_content_t (file (open read getattr map)))
  
  ; Filesystem: write logs
  (allow nginx_t nginx_log_t (dir (search open read write add_name)))
  (allow nginx_t nginx_log_t (file (create open write append getattr)))
  
  ; Filesystem: write cache
  (allow nginx_t nginx_cache_t (dir (search open read write add_name remove_name)))
  (allow nginx_t nginx_cache_t (file (create open read write unlink getattr)))
  
  ; Filesystem: execute binary
  (allow nginx_t nginx_exec_t (file (execute execute_no_trans open read getattr map)))
  
  ; Process: can fork
  (allow nginx_t self (process (fork)))
  
  ; Process: no exec (confined)
  ; (explicitly not granting execute permissions to other types)
  
  ; Unix socket
  (allow nginx_t nginx_t (unix_stream_socket (create bind listen accept connectto)))
  
  ; Constraints: no_new_privileges
  (typemember nginx_t no_new_privs)
  
  ; Constraints: W^X
  (neverallow nginx_t self (process (execmem execstack execheap)))
  
  ; File contexts
  (filecon "/usr/sbin/nginx" file (system_u object_r nginx_exec_t ((s0) (s0))))
  (filecon "/etc/nginx(/.*)?" any (system_u object_r nginx_conf_t ((s0) (s0))))
  (filecon "/var/log/nginx(/.*)?" any (system_u object_r nginx_log_t ((s0) (s0))))
  (filecon "/var/cache/nginx(/.*)?" any (system_u object_r nginx_cache_t ((s0) (s0))))
  (filecon "/var/www(/.*)?" any (system_u object_r nginx_content_t ((s0) (s0))))
  (filecon "/run/nginx\\.pid" file (system_u object_r nginx_cache_t ((s0) (s0))))
  (filecon "/run/nginx\\.sock" socket (system_u object_r nginx_t ((s0) (s0))))
)
```

## Formal Verification

The SPARK policy generator proves several properties:

### Property 1: Completeness

Every declared permission maps to exactly one policy rule. No declarations are silently dropped.

```ada
procedure Generate_Policy (Manifest : in Manifest_Type; Policy : out Policy_Type)
   with Post => 
     (for all Decl of Manifest.SELinux =>
        Exists_Rule (Policy, Corresponding_Rule (Decl)));
```

### Property 2: Minimality

No rules are generated beyond what is declared. No "convenience" permissions.

```ada
function Is_Minimal (Policy : Policy_Type; Manifest : Manifest_Type) return Boolean
   with Post =>
     (for all Rule of Policy.Rules =>
        Is_Required_By (Rule, Manifest.SELinux));
```

### Property 3: No Privilege Escalation

Generated policy cannot grant more privileges than the base container context.

```ada
function No_Escalation (Policy : Policy_Type) return Boolean
   with Post =>
     (for all Rule of Policy.Rules =>
        not Grants_Admin_Capability (Rule) and
        not Allows_Domain_Transition_To_Privileged (Rule));
```

### Property 4: W^X Enforcement

If declared, write and execute permissions are never granted to the same memory.

```ada
function Enforces_WX (Policy : Policy_Type) return Boolean
   with Post =>
     (for all Rule of Policy.Rules =>
        not (Grants_Write (Rule) and Grants_Execute (Rule) and 
             Same_Target (Rule)));
```

## Generation Algorithm

```
GENERATE_POLICY(manifest):
  policy = new CIL_Policy()
  
  # Create types
  domain = create_domain_type(manifest.selinux.domain)
  policy.add_type(domain)
  
  for each path_group in [read, write, execute, create_in]:
    for each path in manifest.selinux.filesystem[path_group]:
      file_type = create_file_type(path, path_group)
      policy.add_type(file_type)
      policy.add_file_context(path, file_type)
  
  # Generate capability rules
  for each cap in manifest.selinux.capabilities:
    policy.add_rule(allow(domain, self, capability, cap))
  
  # Generate network rules
  for each port in manifest.selinux.network.listen_tcp:
    port_type = create_port_type(port)
    policy.add_rule(allow(domain, self, tcp_socket, [create, listen, accept, bind]))
    policy.add_rule(allow(domain, port_type, tcp_socket, name_bind))
    policy.add_port_context(port, port_type)
  
  for each target in manifest.selinux.network.connect_tcp:
    target_type = resolve_target_type(target)
    policy.add_rule(allow(domain, target_type, tcp_socket, name_connect))
  
  # Generate filesystem rules
  for each path in manifest.selinux.filesystem.read:
    file_type = get_file_type(path)
    policy.add_rule(allow(domain, file_type, dir, [search, open, read, getattr]))
    policy.add_rule(allow(domain, file_type, file, [open, read, getattr]))
  
  # ... similar for write, execute, create_in
  
  # Generate process rules
  if manifest.selinux.process.can_fork:
    policy.add_rule(allow(domain, self, process, fork))
  
  if not manifest.selinux.process.can_exec_other:
    # Explicitly confine - no execute on arbitrary types
    policy.add_neverallow(domain, wildcard, file, execute)
  
  # Generate constraints
  if manifest.selinux.constraints.no_new_privileges:
    policy.add_constraint(domain, no_new_privs)
  
  if not manifest.selinux.constraints.memory_execute:
    policy.add_neverallow(domain, self, process, [execmem, execstack, execheap])
  
  return policy
```

## Policy Modes

### Strict Mode (Default)

Only declared permissions are granted. Any undeclared access is denied. Suitable for production containers.

### Learning Mode

Runs with permissive policy while logging denials. Useful for discovering what a container actually needs:

```bash
cerro policy learn nginx.ctp --duration 1h --output learned.ctp
```

This produces a manifest `[selinux]` section based on observed behaviour.

### Audit Mode

Enforcing policy, but with detailed audit logging for all decisions:

```bash
cerro policy audit nginx.ctp
```

## Integration with Container Runtimes

### Podman

```bash
# Generate policy
cerro policy generate nginx.ctp -o nginx.cil

# Load policy
semodule -i nginx.cil

# Run container with policy
podman run --security-opt label=type:nginx_t cerro-torre/nginx:1.26.0
```

### Kubernetes

Cerro Torre provides a policy controller that:
1. Watches for pods with Cerro Torre images
2. Extracts embedded policy from image labels
3. Loads policy into node SELinux
4. Sets pod security context

### OCI Image Integration

Policies are embedded in OCI images as a layer:

```
/etc/selinux/cerro-torre/
  nginx.cil        # CIL policy
  nginx.ctp.json   # Original declarations (for audit)
```

And as image labels:

```
org.cerro-torre.selinux.domain=nginx_t
org.cerro-torre.selinux.policy.sha256=abc123...
```

## Reference Policies

Cerro Torre maintains reference policies for common patterns:

### Web Server (nginx, apache, caddy)
```ctp
[selinux.templates]
use = ["web-server"]
customise.network.listen_tcp = [8080]  # Override default ports
```

### Database (postgres, mysql, sqlite)
```ctp
[selinux.templates]
use = ["database-server"]
customise.filesystem.data_dir = "/var/lib/postgres/data"
```

### Worker (batch processing, no network)
```ctp
[selinux.templates]
use = ["worker-isolated"]
# No network access by default
```

Templates are starting points, not magic. The final policy is always visible and auditable.

## Troubleshooting

### Common Denials

| Denial | Likely Cause | Fix |
|--------|--------------|-----|
| `avc: denied { execute }` | Binary not in execute list | Add to `selinux.filesystem.execute` |
| `avc: denied { name_bind }` | Port not declared | Add to `selinux.network.listen_tcp` |
| `avc: denied { write }` | Path not in write list | Add to `selinux.filesystem.write` |
| `avc: denied { execmem }` | JIT compilation attempted | Set `memory_execute = true` (with caution) |

### Debugging

```bash
# Show all denials for a domain
ausearch -m avc -ts recent | grep nginx_t

# Generate human-readable denial explanation
cerro policy explain "avc: denied { write } ... nginx_t ..."

# Suggest manifest additions for denial
cerro policy suggest denial.log
```

## Security Considerations

### What This Doesn't Protect Against

- Vulnerabilities within allowed operations (e.g., nginx parsing bug)
- Attacks that don't require additional permissions
- Kernel vulnerabilities
- Side-channel attacks

### What This Does Protect Against

- Container escape via filesystem access
- Network pivoting beyond declared destinations
- Privilege escalation via unexpected capabilities
- Data exfiltration via undeclared channels

### Defence in Depth

SELinux policies are one layer. Combine with:
- Seccomp filters (generated similarly from manifest)
- Network policies (Kubernetes NetworkPolicy or CNI)
- Resource limits (cgroups)
- User namespaces

## Changelog

### 0.1.0-draft (2024-12-07)
- Initial draft specification
